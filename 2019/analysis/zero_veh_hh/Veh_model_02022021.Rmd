---
title: "Household Travel Survey, 2017 and 2019: Household Vehicle Count"
author: "Mary Richards"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    df_print: paged
    toc: TRUE
    toc_depth: 6
    toc_float: TRUE
  pdf_document: default
  word_document: default
---

This report presents preliminary findings for household vehicle count trends based on the Household Travel Survey (2017 and 2019), a survey conducted every other year to determine travel patterns for individuals living within PSRC's four-county jurisdiction.

```{r global-options, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, 
                      warning=FALSE, 
                      message=FALSE) # formatting
```

```{r Libraries, include=FALSE}
library(nnet)
library(data.table)
library(tidyverse)
library(DT)
library(openxlsx)
library(odbc)
library(DBI)

library(Hmisc)
library(corrplot)

library(summarytools)
library(stargazer)
library(MASS)
library(caret) #requires lattice and ggplot2
library(lattice)
library(interactions)
library(hablar)
library(reghelper) #for standardizing coefficients

library(reshape2)
library(table1)
library(knitr)
library(kableExtra)
library(interplot) #for ploting interactions
library(DescTools) #for goodness of fit - models
```

## 1. Background Information
This work helps to supplement PSRC's SoundCast Auto Ownership Model (https://www.psrc.org/sites/default/files/2015psrc-modechoiceautomodels.pdf, 2015). According to the results from this model, the most predictive variables are the number of drivers and workers in the household, along with household income. In addition to these variables, the model also considers additional traveler/household characteristics (such as age of household members per driver), transportation level of service variables (such as distance to transit stop and number of transit stops), and land use variables (such as service and retail density). 


The following sections describe the process to understand the important factors that contribute to household vehicle access and count.
\
```{r Data setup, include = FALSE}
# Load Data
parent_folder <- "C:/Users/mrichards/Desktop/test/model_output/"
# parent_folder <- "C:/Users/mrichards/Documents/GitHub/travel-studies/2019/analysis/zero_veh_hh/model_outputs/"

#read in the household table
elmer_connection <- dbConnect(odbc::odbc(),
                              driver = "SQL Server",
                              server = "AWS-PROD-SQL\\Sockeye",
                              database = "Elmer",
                              trusted_connection = "yes")
h <- dbGetQuery(elmer_connection,
                "SELECT * FROM HHSurvey.v_households_2017_2019_in_house")
p <- dbGetQuery(elmer_connection,
                "SELECT * FROM HHSurvey.v_persons_2017_2019_in_house")

dbDisconnect(elmer_connection)


household <- data.table(h)
person <- data.table(p)

# Statistical assumptions for margins of error
p_MOE <- 0.5
z<-1.645
missing_codes <- c('Missing: Technical Error', 'Missing: Non-response', 
                   'Missing: Skip logic', 'Children or missing', 'Prefer not to answer',
                   'Missing')
```

```{r Functions}
# Create a simplified crosstab from one variable, calculate counts, totals, shares, and MOE
# for categorical data
create_table_one_var_simp= function(var1, table_temp, table_type) {
  #table_temp = recategorize_var_upd(var2,table_temp)
  #print(table_temp)
  if (table_type == "household" | table_type == "person" ) {
    weight_2017 = "hh_wt_revised"
    weight_2019 = "hh_wt_2019"
    weight_comb = "hh_wt_combined"
  } else if (table_type == "trip") {
    weight_2017 = "trip_weight_revised"
    weight_2019 = "trip_wt_2019"
    weight_comb = "trip_wt_combined"  
  } 
  
  temp = table_temp %>% dplyr::select(!!sym(var1), all_of(weight_2017), all_of(weight_2019),
                                      all_of(weight_comb)) %>% 
    filter(!.[[1]] %in% missing_codes, !is.na(.[[1]])) %>% 
    group_by(!!sym(var1)) %>% 
    summarise(n=n(),sum_wt_comb = sum(.data[[weight_comb]],na.rm = TRUE), 
              sum_wt_comb = round(sum_wt_comb, 0)) %>% 
    mutate(perc_comb = sum_wt_comb/sum(sum_wt_comb)*100, perc_comb = round(perc_comb, 2)) %>% 
    ungroup() %>%  
    mutate(MOE=1.65*(0.25/sum(n))^(1/2)*100, MOE = round(MOE, 2)) %>% arrange(var1)
  return(temp)
}

#Create a crosstab from two variables, calculate counts, totals, and shares,
# for categorical data
cross_tab_categorical <- function(table, var1, var2, wt_field) {
  expanded <- table %>% 
    group_by(.data[[var1]],.data[[var2]]) %>%
    dplyr::summarize(Count= n(),Total=sum(.data[[wt_field]])) %>%
    group_by(.data[[var1]])%>%
    mutate(Percentage=Total/sum(Total)*100)
  
  
  expanded_pivot <-expanded%>%
    pivot_wider(names_from=.data[[var2]], values_from=c(Percentage,Total, Count))
  
  return (expanded_pivot)
  
} 

# Create margins of error for dataset
categorical_moe <- function(sample_size_group){
  sample_w_MOE<-sample_size_group %>%
    mutate(p_col=p_MOE) %>%
    mutate(MOE_calc1= (p_col*(1-p_col))/sample_size) %>%
    mutate(MOE_Percent=z*sqrt(MOE_calc1)*100)
  
  sample_w_MOE<- dplyr::select(sample_w_MOE, -c(p_col, MOE_calc1))
  
  return(sample_w_MOE)
}

# create table with bivariate analysis stats
bivariate_Pvalue <- function(outcome, explanatory){
  model_output <- polr(as.factor(outcome) ~ explanatory, Hess=T)
  ctable <- coef(summary(model_output))
  # calculate and store p values
  p <- pnorm(abs(ctable[,"t value"]), lower.tail = F)*2
  p_round <- round(pnorm(abs(ctable[,"t value"]), lower.tail = F)*2,4)
  #odds ratio
  oddsratio <- round(exp(coef(model_output)),4)
  #combine elements
  ctable <- cbind(round(ctable,4), "p-value"=p, "simp p."=p_round, "odds ratio"=oddsratio)
  return(ctable)
}

# create stargazer table
stargazer_table <- function(outcome, explanatory, table_title){
  stargazer::stargazer(
    polr(as.factor(outcome) ~ explanatory, Hess=T), type = "html",
                      title =  table_title,
                      notes.append =  FALSE, 
                      notes =  c("<sup>&sstarf;</sup>p<0.1; <sup>&sstarf;&sstarf;</sup>p<0.05; <sup>&sstarf;&sstarf;&sstarf;</sup>p<0.01"))

}

# rounding function applied to categorical columns 
my.render.cat <- function(x) {
    c("", sapply(stats.default(x), function(y) with(y,
        sprintf("%d (%.0f%%)", FREQ, PCT))))}
```

## 2. Dependent Variables
The two potential dependent variables for these models are at the household level (by `household_id`):  

1. Vehicle count - the number of vehicles owned (reported by survey respondents)
2. Vehicle access - the number of household vehicles owned in relation to the number of workers in each household


### a. Household Vehicle Count
Survey Responses:  
*"How many motor vehicles (in working order) are there in your household?"*
```{r Vehicle Count: Original Data}
household$vehcount_ordered <- factor(household$vehicle_count,
                                                levels=c("0 (no vehicles)","1","2","3","4","5",
                                                         "6","7","8","9","10 or more vehicles"))

table1(~vehcount_ordered, data=household, render.categorical=my.render.cat)
```
\
```{r Vehicle Count: MOE}
x <- create_table_one_var_simp("vehcount_ordered",household, "household")
print(as_tibble(x), n = 12)
```

Based on survey responses, there is a very small number of households with more than 3 vehicles, so these households are grouped together.

*Number of workers by household id*
```{r Grouping vehicle count}
household <- household %>% 
  mutate(vehicle_group = case_when(vehicle_count== "0 (no vehicles)" ~ 0,
                                   vehicle_count == "1" ~ 1,
                                   vehicle_count == "2" ~ 2,
                                   TRUE ~ 3))

household$vehicle_group <- as_factor(household$vehicle_group)
table1(~vehicle_group, data=household, render.categorical=my.render.cat)
```

```{r Vehicle Count regrouped: MOE}
x <- create_table_one_var_simp("vehicle_group",household, "household")
print(as_tibble(x))
```


### b. Household Vehicle Access
This variable is based on the number of household vehicles (explained above) and the number of workers within the household. 
```{r Number of household workers}
# # look at vehicle access by number of workers in a household
# unique(person_and_household$numworkers)
household$numworkers <- as_factor(household$numworkers)
table1(~numworkers, data=household, render.categorical=my.render.cat)
```

```{r Number of household workers: MOE}
x <- create_table_one_var_simp("numworkers",household, "household")
print(as_tibble(x))
```
\
Based on survey responses, there is a very small number of households with more than 3 workers, so these households are grouped together
```{r Grouping household workers}
household <- household %>% 
  mutate(numworkers_group = case_when(numworkers== "0" ~ 0,
                                   numworkers == "1" ~ 1,
                                   numworkers == "2" ~ 2,
                                   TRUE ~ 3))
household$numworkers_group <- as.factor(household$numworkers_group)
table1(~numworkers_group, data=household, render.categorical=my.render.cat)
```

```{r Grouping household workers: MOE}
x <- create_table_one_var_simp("numworkers_group",household, "household")
print(as_tibble(x))
```
\
**Vehicle Access is calculated by comparing the number of vehicles and the number of workers per household**

* *limited access*:  vehicles < workers
* *equal access*:  vehicles = workers
* *good access*: vehicles > workers

```{r calculating vehicle access}
# compare veh count and numworkers to get vehicle access
# convert "vehicle_group" and "numworkers_group" from factor to numeric
household$vehicle_group <- as.numeric(as.character(household$vehicle_group))
household$numworkers_group <- as.numeric(household$numworkers_group)

household <- household %>%
  mutate(hh_veh_access = case_when(vehicle_group < numworkers_group ~ 'Reduced access',
                                   vehicle_group == numworkers_group ~ 'Equal access',
                                   vehicle_group > numworkers_group ~ 'Good access'))

household$hh_veh_access <- factor(household$hh_veh_access, 
                                  levels=c("Reduced access", "Equal access","Good access"))
table1(~hh_veh_access, data=household, render.categorical=my.render.cat)
```

Although vehicle access is an interesting measurement to explore, it requires a few levels of aggregation and adjustment, which could introduce error or oversimplification. Therefore, analysis will be based on the count of vehicles per household. 
\
\

## 3. Explanatory or predictor variables
There are many personal and household characteristics that can contribute to vehicle count at the household level. 
\
Based on these considerations and the data available through survey responses, the following table will attempt to match the person-level and household-level characteristics with responses provided by the survey participants. The data listed in the right column are from the in-house person (p) and household (h) views, available through Elmer, or describe an externally-sourced dataset (e).  

```{r characteristics and corresponding survey questions}
c1 <- as.data.frame(c(
  "1. Income",
  "2. Gender",
  "3. Age",
  "4. Household size",
  "5. Number of licensed (or licensed age) individuals",
  "6. Occupation",
  "7. Educational Attainment",
  "8. Number of workers",
  "9. Household lifecycle or age composition of household members",
  "10. Race or ethnicity",
  "11. Physical disabilities",
  "12. Housing type",
  "13. Housing or work location and proximity to transit",
  "14. Commuting patterns",
  "15. Quality of transit options available",
  "16. Housing proximity to services",
  "17. Environmental consciousness"))
colnames(c1)[1] <- "Vehicle-ownership Considerations"
c2 <- as.data.frame(c(
  "*hhincome_broad (p/h), hhincome_detailed (p/h)*",
  "*gender (p)*",
  "*age (p), age_category (p)*",
  "*hhsize (p/h)*",
  "*license (p)*",
  "*employment (p), jobs_count (p)*",
  "*education (p)*",
  "*numworkers (h)*",
  "*lifecycle (p/h)*",
  "*race_category (p)*",
  "*?*",
  "*rent_own (h), res_type (h)*",
  "*final_home_rgcnum (h), seattle_home (h)*",
  "*commute_freq (p), commute_mode (p), commute_dur (p), telecommute_freq (p)*",
  "*transit score by block group (e)*",
  "*displacement risk index (e)*",
  "*?*"))
colnames(c2)[1] <- "Survey Variables"

corresponding <- cbind(c1,c2)

# print table using kable()
kable(corresponding, format = "html",escape = FALSE, align = c('l','l')) %>% kable_styling("bordered",full_width = F, position = "left") #%>% column_spec(2, color = "red")#%>% column_spec(2, bold = T)
```
\
Because the dependent variable is household vehicle count, the person-level variables need to be aggregated to the household level. With this in mind, gender and employment type were removed from this analysis.  
\
The table below illustrates the person-level variables related to vehicle count and the way in which they were aggregated:
```{r person-level characteristics and corresponding stats methods}
c1 <- as.data.frame(c(
  "Number of licensed (or licensed age) individuals",
  "Number of jobs",
  "Educational Attainment",
  "Commuting Patterns
  \n* Distance (mi) by automobile
  \n* Time (min) by automobile
  \n* Commute frequency (days/week)"))
colnames(c1)[1] <- "Person-level variables"
c2 <- as.data.frame(c(
  "sum",
  "sum",
  "min, max",
  "\nmean, sum
  \nmean, sum
  \nmin, max"))
colnames(c2)[1] <- "Aggregation method(s)"

corresponding <- cbind(c1,c2)

# print table using kable()
kable(corresponding, format = "html",escape = FALSE, align = c('l','l')) %>% kable_styling("bordered",full_width = F, position = "left") #%>% column_spec(2, color = "red")#%>% column_spec(2, bold = T)
```

In addition to these variables, two additional ones were calculated:  

* Number of household jobs per worker (sum of household jobs/numworkers)  
* Number of household commute trips per week (sum of household commute trips/(numworkers*5))

```{r HOUSEHOLD TABLE, include = FALSE}
# this has some information on the Census Tract level that could be useful
displ_index_data<- 'C:/Users/mrichards/Documents/GitHub/travel-studies/2019/analysis/zero_veh_hh/displacement_risk_estimation.csv'
displ_risk_df <- read.csv(displ_index_data)
transit_score_data <- 'C:/Users/mrichards/Documents/GitHub/travel-studies/2019/analysis/zero_veh_hh/bg_transit_score2018_2_sf_10302020.csv'
transit_sc_df <- read.csv(transit_score_data)

# merge the households to info about the tracts/blocks they live in - displacement risk/transit score (Stefan)
household$final_home_tract<- as.character(household$final_home_tract)
household$final_home_bg<- as.character(household$final_home_bg)
# displacement risk - by tract
displ_risk_df$GEOID<-as.character(displ_risk_df$GEOID)
household <- merge(household,displ_risk_df, by.x='final_home_tract', by.y='GEOID', all.x=TRUE)
# glimpse(household)
# transit score - by block
transit_sc_df$geoid10<-as.character(transit_sc_df$geoid10)
# glimpse(transit_sc_df$geoid10)
# glimpse(household$final_home_bg)
household <- merge(household, transit_sc_df, by.x='final_home_bg', by.y='geoid10', all.x=TRUE )
# glimpse(household)
# nrow(household)
household$household_id <- as.character(household$household_id)
```

```{r PERSON TABLE description, include=FALSE}
# need to summarise the variables of interest so that they can be representative at the household level
# to prepare the variables for aggregation: 
    # licenses, employment, educational attainment, commuting patterns
```

```{r license : person table, include=FALSE}
# freq(person$license)
table(person$license)


# simplify license status
person <- person %>% 
  mutate(license_simp = case_when(
    license == "No, does not have a license or permit" ~ "Non-driver",
    license == "Missing: Skip logic" ~ "Missing",
    TRUE ~ "Driver"))
table(person$license_simp)


# assign those categorized as drivers with number, so that the total can be determined by household
person <- person %>%
  mutate(driver = case_when(license_simp=="Driver"~ 1,
                            license_simp=="Non-driver"~ 0,
                            TRUE~ as.numeric(NA))) 
person$household_id <- as.character(person$household_id)
```

```{r employment : person table, include=FALSE}
# freq(person$employment)
freq(person$jobs_count)

# convert jobs count to numeric to allow for aggregation
person <- person %>%
  mutate(jobs_count_num = case_when(jobs_count=="0 jobs"~0,
                                    jobs_count=="1 job"~1,
                                    jobs_count=="2 jobs"~2,
                                    jobs_count=="3 jobs"~3,
                                    jobs_count=="4 jobs"~4,
                                    jobs_count=="5 or more jobs"~5,
                                    TRUE~ as.numeric(NA)))
freq(person$jobs_count_num)
```

```{r education : person table, include=FALSE}
freq(person$education)
table(person$education)

# convert to numbers to allow for aggregation
person <- person %>%
  mutate(education_num = case_when(education=="Associates degree"~ 5,
                                   education=="High school graduate"~ 2,
                                   education=="Some college" ~ 4,
                                   education=="Bachelor degree" ~ 6,
                                   education=="Less than high school" ~ 1,
                                   education=="Vocational/technical training" ~ 3,
                                   education=="Graduate/post-graduate degree" ~ 7, 
                                   TRUE~ as.numeric(NA))) 

# to check if "some college" is only for younger respondents (under 25yo: 107/1154; <10%)
# xtabs(~education+age, data=person) 
```

```{r commuting patterns : person table, include=FALSE}
summary(person$commute_auto_distance) #very high MAX values
summary(person$commute_auto_time) #very high MAX values
freq(person$commute_freq)
# freq(person$commute_dur) # ? not very helpful
# freq(person$commute_mode) # indirectly related
# freq(person$simp_commute) # indirectly related
# freq(person$work_park_type) # indirectly related

# filter out outliers from auto commute distance and time
# person <- person %>%
#   mutate(com_auto_dist_cleaned =) %>%
#   mutate(com_auto_time_cleaneed =)

# convert to numbers to allow for aggregation (sum)
person <- person %>%
  mutate(commute_freq_num = case_when(commute_freq=="1 day a week"~ 1,
                                      commute_freq=="2 days a week"~ 2,
                                      commute_freq=="3 days a week"~ 3,
                                      commute_freq=="4 days a week"~ 4,
                                      commute_freq=="5 days a week"~ 5,
                                      commute_freq=="6-7 days a week"~ 6,
                                      TRUE~ as.numeric(NA))) 

# convert to numbers to allow for aggregation (min/max)
person <- person %>%
  mutate(commute_freq_num_all = case_when(commute_freq=="Less than monthly"~ 1,
                                          commute_freq=="A few times per month"~ 2,
                                          commute_freq=="1 day a week"~ 3,
                                          commute_freq=="2 days a week"~ 4,
                                          commute_freq=="3 days a week"~ 5,
                                          commute_freq=="4 days a week"~ 6,
                                          commute_freq=="5 days a week"~ 7,
                                          commute_freq=="6-7 days a week"~ 8,
                                          TRUE~ as.numeric(NA)))

# simplify categories
person <- person %>%
  mutate(commute_freq_simpnum = case_when(commute_freq=="Less than monthly" |
                                        commute_freq== "A few times per month"~ 1,
                                      commute_freq=="1 day a week" |
                                        commute_freq=="2 days a week" |
                                        commute_freq=="3 days a week"~ 2,
                                      commute_freq=="4 days a week" |
                                        commute_freq=="5 days a week" |
                                        commute_freq=="6-7 days a week"~ 3,
                                      TRUE~ as.numeric(NA))) 
freq(person$commute_freq_num)
freq(person$commute_freq_simpnum)
```

```{r aggregating person table, include=FALSE}
# person_hh <- person %>%
#   #dplyr::select(household_id, driver, hh_wt_combined) %>%
#   group_by(household_id) %>%
#   summarise(hh_driver = sum(driver, na.rm=T),
#             hh_jobs = sum(jobs_count_num, na.rm=T),
#             hh_edu_min = min(education_num, na.rm=T), 
#             hh_edu_max = max(education_num, na.rm=T),
#             # but use 'education' for stats to keep text, simplify to fewer categories?
#             hh_commute_freq_min = min(commute_freq_simpnum, na.rm=T),
#             hh_commute_freq_max = max(commute_freq_simpnum, na.rm=T),
#             hh_commute_freq_sum = sum(commute_freq_num, na.rm=T),
#             hh_com_auto_time_avg = mean(commute_auto_time, na.rm=T),
#             hh_com_auto_time_sum = sum(commute_auto_time, na.rm=T),
#             hh_com_auto_dist_avg = mean(commute_auto_distance, na.rm=T),
#             hh_com_auto_dist_sum = sum(commute_auto_distance, na.rm=T))

person_hh <- person %>%
  #dplyr::select(household_id, driver, hh_wt_combined) %>%
  group_by(household_id) %>%
  summarise(hh_driver = sum(driver, na.rm=T),
            hh_jobs = sum(jobs_count_num, na.rm=T),
            hh_edu_min = min_(s(education_num)), 
            hh_edu_max = max_(s(education_num)),
            # requires hablar package to return NA instead of Inf
            hh_commute_freq_origmin = min_(s(commute_freq_num_all)),
            hh_commute_freq_origmax = max_(s(commute_freq_num_all)),
            hh_commute_freq_min = min_(s(commute_freq_simpnum)),
            hh_commute_freq_max = max_(s(commute_freq_simpnum)),
            hh_commute_freq_sum = sum(commute_freq_num, na.rm=T),
            hh_com_auto_time_avg = mean(commute_auto_time, na.rm=T),
            hh_com_auto_time_sum = sum(commute_auto_time, na.rm=T),
            hh_com_auto_dist_avg = mean(commute_auto_distance, na.rm=T),
            hh_com_auto_dist_sum = sum(commute_auto_distance, na.rm=T))
nrow(person_hh) # check number of rows after grouping by household_id
max
# recategorize education to text
person_hh$hh_edu_min <- as.character(person_hh$hh_edu_min)
person_hh$hh_edu_max <- as.character(person_hh$hh_edu_max)

person_hh <- person_hh %>%
  mutate(education_min = case_when(hh_edu_min=="5"~"Associates degree",
                                   hh_edu_min=="2"~"High school graduate",
                                   hh_edu_min=="4"~"Some college",
                                   hh_edu_min=="6"~"Bachelor degree",
                                   hh_edu_min=="1"~"Less than high school",
                                   hh_edu_min=="3"~"Vocational/technical training",
                                   hh_edu_min=="7"~"Graduate/post-graduate degree", 
                                   TRUE~ as.character(NA))) %>%
  mutate(education_max = case_when(hh_edu_max=="5"~"Associates degree",
                                   hh_edu_max=="2"~"High school graduate",
                                   hh_edu_max=="4"~"Some college",
                                   hh_edu_max=="6"~"Bachelor degree",
                                   hh_edu_max=="1"~"Less than high school",
                                   hh_edu_max=="3"~"Vocational/technical training",
                                   hh_edu_max=="7"~"Graduate/post-graduate degree", 
                                   TRUE~ as.character(NA)))
person_hh$education_min <- factor(person_hh$education_min,
                                     levels=c("Less than high school",
                                              "High school graduate",
                                              "Vocational/technical training",
                                              "Some college",
                                              "Associates degree",
                                              "Bachelor degree",
                                              "Graduate/post-graduate degree",
                                              "Missing: Skip logic"))
person_hh$education_max <- factor(person_hh$education_max,
                                     levels=c("Less than high school",
                                              "High school graduate",
                                              "Vocational/technical training",
                                              "Some college",
                                              "Associates degree",
                                              "Bachelor degree",
                                              "Graduate/post-graduate degree",
                                              "Missing: Skip logic"))

# simplify the number of drivers - grouping households with 4+ licenses
person_hh <- person_hh %>%
  mutate(driver_simp = case_when(hh_driver== 5 ~ 4,
                                 hh_driver== 6 ~ 4,
                                 hh_driver== 7 ~ 4,
                                 hh_driver== 9 ~ 4,
                                 TRUE~.$hh_driver)) 
person_hh$driver_simp <- as.factor(person_hh$driver_simp)
freq(person_hh$driver_simp)

# recategorize full commute frequency to text
person_hh$hh_commute_freq_origmin <- as.character(person_hh$hh_commute_freq_origmin) #mutate() not working if hh_commute_freq_origmin is numeric
person_hh$hh_commute_freq_origmax <- as.character(person_hh$hh_commute_freq_origmax)

person_hh <- person_hh %>%
  dplyr::mutate(commute_freq_min = case_when(hh_commute_freq_origmin=="1"~ "Less than monthly",
                                           hh_commute_freq_origmin=="2"~ "A few times per month",
                                           hh_commute_freq_origmin=="3"~ "1 day a week",
                                           hh_commute_freq_origmin=="4"~ "2 days a week",
                                           hh_commute_freq_origmin=="5"~ "3 days a week",
                                           hh_commute_freq_origmin=="6"~ "4 days a week",
                                           hh_commute_freq_origmin=="7"~ "5 days a week",
                                           hh_commute_freq_origmin=="8"~ "6-7 days a week",
                                           TRUE~ as.character(NA))) %>%
  dplyr::mutate(commute_freq_max = case_when(hh_commute_freq_origmax=="1"~ "Less than monthly",
                                           hh_commute_freq_origmax=="2"~ "A few times per month",
                                           hh_commute_freq_origmax=="3"~ "1 day a week",
                                           hh_commute_freq_origmax=="4"~ "2 days a week",
                                           hh_commute_freq_origmax=="5"~ "3 days a week",
                                           hh_commute_freq_origmax=="6"~ "4 days a week",
                                           hh_commute_freq_origmax=="7"~ "5 days a week",
                                           hh_commute_freq_origmax=="8"~ "6-7 days a week",
                                           TRUE~ as.character(NA)))
freq(person_hh$commute_freq_min)
freq(person_hh$commute_freq_max)

# recategorize simplified commute frequency to text
person_hh <- person_hh %>%
  mutate(commute_freq_simp_min = case_when(hh_commute_freq_min==1~ "Less than once a week",
                                           hh_commute_freq_min==2~ "3 or fewer days a week",
                                           hh_commute_freq_min==3~ "4 or more days a week",
                                           TRUE~ as.character(NA))) %>%
  mutate(commute_freq_simp_max = case_when(hh_commute_freq_max==1~ "Less than once a week",
                                           hh_commute_freq_max==2~ "3 or fewer days a week",
                                           hh_commute_freq_max==3~ "4 or more days a week",
                                           TRUE~ as.character(NA)))

#reorder based on frequency
person_hh$commute_freq_simp_min <-
  factor(person_hh$commute_freq_simp_min,
         levels=c("Less than once a week", 
                  "3 or fewer days a week",
                  "4 or more days a week"))
person_hh$commute_freq_simp_max <-
  factor(person_hh$commute_freq_simp_max,
         levels=c("Less than once a week", 
                  "3 or fewer days a week",
                  "4 or more days a week"))

freq(person_hh$commute_freq_simp_min)
freq(person_hh$commute_freq_simp_max)
summary(person_hh$hh_commute_freq_sum)


glimpse(person_hh)
```
  
```{r JOIN household and person tables, include=FALSE}
person_and_household <- left_join(person_hh, household,
                                  by=c("household_id"="household_id"))

# add variables using both tables
person_and_household$numworkers_num <- as.numeric(person_and_household$numworkers)
person_and_household <- person_and_household %>%
  mutate(jobs_numworkers = hh_jobs/numworkers_num, na.rm=T) %>% # if 1: every worker has 1 job
  mutate(hh_commutetrips = hh_commute_freq_sum/(numworkers_num*5), na.rm=T) # if 1: all workers commuting every weekday

nrow(person_and_household) # check numner of rows: 6319
glimpse(person_and_household)
```
\

### a. Univariate analysis
The dependent variable or outcome will be vehicle count (`vehicle_group`: 0, 1, 2, 3+) and the independent or explanatory variables will be from the list above. Because the vehicle count is ordinal, an ordered logit model will be applied.

The following section will introduce descriptive statistics for each of the explanatory variables, followed by analysis. For an overview of the results from these individual analyses, please skip to section 3b.
\
\

#### <span style="color:#009D6A">*1. Income*</span>  
The survey variable `hhincome_broad` is divided into 5 categories, while the survey variable "hhincome_detailed" is divided into 10 categories. Although the broader categories do not provide as much detail, the sample sizes within each category are larger and there are fewer households who chose "Prefer not to answer" (broad: 829, detailed: 1,309). 
```{r}
#  income : stats 
# freq(person_and_household$hhincome_broad)

person_and_household$hhincomeb_reordered <- factor(person_and_household$hhincome_broad, 
                                                   levels=c("Under $25,000","$25,000-$49,999",
                                                            "$50,000-$74,999","$75,000-$99,999",
                                                            "$100,000 or more","Prefer not to answer"))
# table(person_and_household$hhincomeb_reordered)
table1(~hhincomeb_reordered, data=person_and_household, render.categorical=my.render.cat)

```

```{r income : MOE setup, include=FALSE}
# User defined variables on each analysis:
# this is the weight for summing in your analysis
hh_wt_field<- 'hh_wt_combined'
# # this is a field to count the number of records
# person_count_field<-'person_dim_id'
# this is how you want to group the data in the first dimension,
# this is how you will get the n for your sub group
group_cat <- 'hhincomeb_reordered'
# this is the second variable you want to summarize by
var <-  'vehicle_group'
# filter data missing weights
hh_no_na<-person_and_household %>% drop_na(all_of(hh_wt_field))
#filter data missing values
#before you filter out the data, you have to investigate if there are any NAs or missing values in your variables and why they are there.
sum(is.na(person_and_household$household_id))
#if you think you need to filter out NAs and missing categories, please use the code below
# hh_no_na = hh_no_na %>%
#   filter(!hhincomeb_reordered %in% missing_codes,
#          !is.na(hhincomeb_reordered))
# now find the sample size of your subgroup
sample_size_group<- hh_no_na %>%
  group_by(hhincomeb_reordered) %>%
  dplyr::summarize(sample_size = n())
sample_size_group
# get the margins of error for your groups
sample_size_MOE<- categorical_moe(sample_size_group)
# calculate totals and shares
cross_table<-cross_tab_categorical(hh_no_na,group_cat,var, hh_wt_field)
# merge the cross tab with the margin of error
cross_table_w_MOE<-merge(cross_table, sample_size_MOE, by=group_cat, sort=FALSE)
```

```{r}
# income : vehicle ownership MOE
cross_table_w_MOE
```

```{r}
# income : vehicle ownership plot
# xtabs(~vehicle_group + hhincomeb_reordered, data = person_and_household)
hh_vehcount_income <- person_and_household %>%
  filter(!is.na(hhincomeb_reordered)) %>%
  group_by(hhincomeb_reordered,vehicle_group) %>%
  summarise(n=n(), HouseholdWeight = sum(hh_wt_combined))
# hh_vehcount_income 

ggplot(data=hh_vehcount_income, aes(x=hhincomeb_reordered, y=n, fill= vehicle_group)) +
  geom_bar(stat="identity") +
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5)) +
  labs(x = "Income (broad)", 
       y = "Survey Responses", 
       fill = "Vehicle Count",
       title = "Vehicle Count by Income")
```


Reference group: Under $25,000
```{r}
# income : bivariate analysis
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$hhincomeb_reordered)
```

```{r, results='asis'}
# income : stargazer table
stargazer_table(person_and_household$vehicle_group,
                person_and_household$hhincomeb_reordered,
                'Vehicle Count by Income')
```
\
<span style="color:#20b2aa">In reference to the households making under $25k, households in higher income categories are more likely to own more vehicles. This positive association between household income and household vehicle count is statistically significant.</span>
\
\

#### <span style="color:#009D6A">*2. Age/Lifecycle*</span>  
Person-level ages are likely to influence household vehicle count, but because the variable of interest is vehicle count, the household age composition or household lifecycle will be evaluated.

Households were organized into four categories based on the composition and age of people in the household:  

* *Households with children:* any household with at least one member under age 18  
* *Households with younger adults:* any household without children where all adults are age 18-34  
* *Households with older adults:* any household without children where all adults are age 18-64 and at least one adult is age 35-64  
* *Households with seniors:* any household with at one adult age 65 and older

```{r ageLifecycle : stats}
# freq(person_and_household$lifecycle)
# table(person_and_household$lifecycle)
table1(~lifecycle, data=person_and_household, render.categorical=my.render.cat)
person_and_household$lifecycle <- as_factor(person_and_household$lifecycle)
```
\

Because of the large number of categories - accounting for both size and age, they are reduced to reflect only age ranges
```{r ageLifecycle : setup}
person_and_household <- person_and_household %>%
  mutate(hh_lifecycle = case_when(lifecycle == "Household size = 1, Householder under age 35" |
                                    lifecycle == "Household size > 1, Householder under age 35" ~
                                    "Under age 35",
                                  lifecycle == "Household size = 1, Householder age 35 - 64" |
                                    lifecycle == "Household size > 1, Householder age 35 - 64" ~ 
                                    "Age 35-64",
                                  lifecycle == "Household size = 1, Householder age 65+" |
                                    lifecycle == "Household size > 1, Householder age 65+" ~
                                    "Age 65+",
                                  lifecycle == "Household includes children under 5" ~
                                    "With children under 5",
                                  lifecycle == "Household includes children age 5-17" ~
                                    "With children age 5-17"))

person_and_household$hh_lifecycle <- factor(person_and_household$hh_lifecycle, 
                                            levels=c("Under age 35","Age 35-64",
                                                     "Age 65+","With children under 5",
                                                     "With children age 5-17"))
# freq(person_and_household$hh_lifecycle)
# table(person_and_household$hh_lifecycle)
table1(~hh_lifecycle, data=person_and_household, render.categorical=my.render.cat)

```

```{r ageLifecycle : MOE setup, include=FALSE}
# User defined variables on each analysis:
# this is the weight for summing in your analysis
hh_wt_field<- 'hh_wt_combined'
# # this is a field to count the number of records
# person_count_field<-'person_dim_id'
# this is how you want to group the data in the first dimension,
# this is how you will get the n for your sub group
group_cat <- 'hh_lifecycle'
# this is the second variable you want to summarize by
var <- 'vehicle_group'
# filter data missing weights
hh_no_na<-person_and_household %>% drop_na(all_of(hh_wt_field))
#filter data missing values
#before you filter out the data, you have to investigate if there are any NAs or missing values in your variables and why they are there.
sum(is.na(household$household_id))
#if you think you need to filter out NAs and missing categories, please use the code below
# hh_no_na = hh_no_na %>%
#   filter(!hh_lifecycle %in% missing_codes,
#          !is.na(hh_lifecycle))
# now find the sample size of your subgroup
sample_size_group<- hh_no_na %>%
  group_by(hh_lifecycle) %>%
  dplyr::summarize(sample_size = n())
sample_size_group
# get the margins of error for your groups
sample_size_MOE<- categorical_moe(sample_size_group)
# calculate totals and shares
cross_table<-cross_tab_categorical(hh_no_na,group_cat,var, hh_wt_field)
# merge the cross tab with the margin of error
cross_table_w_MOE<-merge(cross_table, sample_size_MOE, by=group_cat, sort=FALSE)
```

```{r ageLifecycle : vehicle ownership MOE}
cross_table_w_MOE
```

```{r ageLifecycle vehicle ownership plot}
# xtabs(~vehicle_group + hhincomeb_reordered, data = person_and_household)
hh_vehcount_lifecycle <- person_and_household %>%
  filter(!is.na(hh_lifecycle)) %>%
  group_by(hh_lifecycle,vehicle_group) %>%
  summarise(n=n(), HouseholdWeight = sum(hh_wt_combined))
# hh_vehcount_lifecycle 

ggplot(data = hh_vehcount_lifecycle, aes(x=hh_lifecycle, y=n, fill= vehicle_group)) +
  geom_bar(stat="identity") +
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5)) +
  labs(x = "Household Lifecycle", 
       y = "Survey Responses", 
       fill = "Vehicle Count",
       title = "Vehicle Count by Household age composition")
```

Reference group: Under age 35
```{r ageLifecycle : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$hh_lifecycle)
```

```{r ageLifecycle : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group, 
                 person_and_household$hh_lifecycle,
                "Vehicle Count by Household Lifecycle")
```
\
<span style="color:#20b2aa">The relationship between household lifecycle and household vehicle count is  statistically significant, with households with children owning more vehicles, especially those with children ages 5-17, likely because of lifestyle requirements and housing patterns. Households with individuals 65+ are more likely to own more vehicles than households ages 35-64, likely because of mobility considerations and housing patterns. All of the household lifecycle categories included in the table above are more likely to own more vehicles than households under age 35.</span>
\
\

#### <span style="color:#009D6A">*3. Household size*</span>  
The survey question provides respondents with 9 options for household size. 
\
\
Original Data
```{r household size}
# unique(person_and_household$hhsize)
# freq(person_and_household$hhsize)

# table(person_and_household$hhsize)
table1(~hhsize, data=person_and_household, render.categorical=my.render.cat)
```
Because there are so few people with more than 5 people, these households have been combined together into one category for analysis.
```{r household size : simplified}
person_and_household <- person_and_household %>%
  mutate(hhsize_simp = case_when(hhsize =="5 people" |
                                   hhsize == "6 people" |
                                   hhsize == "7 people" |
                                   hhsize == "8 people" |
                                   hhsize == "9 people" ~ "5 or more people",
                                 TRUE~.$hhsize))
# table(person_and_household$hhsize_simp)

table1(~hhsize_simp, data=person_and_household, render.categorical=my.render.cat)
```

```{r household size : simplified - numeric, include=FALSE}
# convert hhsize variable to numeric
person_and_household <- person_and_household %>%
  mutate(hhsize_simp_num = case_when(hhsize_simp == "1 person" ~ "1",
                                     hhsize_simp == "2 people" ~ "2",
                                     hhsize_simp == "3 people" ~ "3",
                                     hhsize_simp == "4 people" ~ "4",
                                     hhsize_simp == "5 or more people" ~ "5",
                                     TRUE~.$hhsize_simp))
person_and_household$hhsize_simp_num <- as.numeric(person_and_household$hhsize_simp_num)
# class(person_and_household$hhsize_simp_num)

table1(~hhsize_simp_num, data=person_and_household, render.categorical=my.render.cat)
```

```{r household size : MOE setup, include=FALSE}
# User defined variables on each analysis:
# this is the weight for summing in your analysis
hh_wt_field<- 'hh_wt_combined'
# # this is a field to count the number of records
# person_count_field<-'person_dim_id'
# this is how you want to group the data in the first dimension,
# this is how you will get the n for your sub group
group_cat <- 'hhsize_simp_num'
# this is the second variable you want to summarize by
var <- 'vehicle_group'
# filter data missing weights
hh_no_na<-person_and_household %>% drop_na(all_of(hh_wt_field))
#filter data missing values
#before you filter out the data, you have to investigate if there are any NAs or missing values in your variables and why they are there.
sum(is.na(household$household_id))
#if you think you need to filter out NAs and missing categories, please use the code below
# hh_no_na = hh_no_na %>%
#   filter(!hhincomeb_reordered %in% missing_codes,
#          !is.na(hhsize_simp))
# now find the sample size of your subgroup
sample_size_group<- hh_no_na %>%
  group_by(hhsize_simp_num) %>%
  dplyr::summarize(sample_size = n())
sample_size_group
# get the margins of error for your groups
sample_size_MOE<- categorical_moe(sample_size_group)
# calculate totals and shares
cross_table<-cross_tab_categorical(hh_no_na,group_cat,var, hh_wt_field)
# merge the cross tab with the margin of error
cross_table_w_MOE<-merge(cross_table, sample_size_MOE, by=group_cat)
```

```{r household size : vehicle ownership MOE}
cross_table_w_MOE
```

```{r household size vehicle ownership plot}
# xtabs(~vehicle_group + hhincomeb_reordered, data = person_and_household)
hh_vehcount_hhsize <- person_and_household %>%
  filter(!is.na(hhsize_simp_num)) %>%
  group_by(hhsize_simp_num,vehicle_group) %>%
  summarise(n=n(), HouseholdWeight = sum(hh_wt_combined))
# hh_vehcount_hhsize 

ggplot(data =hh_vehcount_hhsize, aes(x=hhsize_simp_num, y=n, fill= vehicle_group)) +
  geom_bar(stat="identity") +
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5)) +
  labs(x = "Household size", 
       y = "Survey Responses", 
       fill = "Vehicle Count",
       title = "Vehicle Count by Household size")
```

```{r household size : stats}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$hhsize_simp_num)
```

```{r household size : bivariate analysis, results='asis'}
stargazer_table(person_and_household$vehicle_group,
                person_and_household$hhsize_simp_num,
                'Vehicle Count by Household size')
```
\
<span style="color:#20b2aa">In reference to the households with one person, households with more people are more likely to own more vehicles. This positive association between household income and household vehicle ownership is statistically significant.</span>
\
\

#### <span style="color:#009D6A">*4. Number of household licenses*</span>  
Original data at a person level (11,940 survey respondents)
```{r license}
# freq(person_and_household$license)

# table(person$license)
table1(~license, data=person, render.categorical=my.render.cat)
```
\
These categories have been simplified to drivers or non-drivers. Those with a permit are considered to be drivers as they are in the pursuit of a license. Despite this recategorization, there is a large disparity between these groups, with over 10 times as many people reporting that they have a license.  
```{r license : simplified}
# table(person$license_simp)
table1(~license_simp, data=person, render.categorical=my.render.cat)
```
\
The person level data of having a license is aggregated to the household level. The following values reflect the number of licenses within each surveyed household (6,319 households). 
```{r number license}
freq(person_and_household$hh_driver)
# person_and_household$hh_driver <- as.factor(person_and_household$hh_driver)
# table1(~hh_driver, data=person_and_household, render.categorical=my.render.cat)
```
\
Because there are so few households with more than 4 drivers, these categories have been simplified.  
```{r number license : simplified - numeric}
person_and_household$driver_simp <- as.numeric(person_and_household$driver_simp)
freq(person_and_household$driver_simp)
```
\
Margin of Error
```{r number license : MOE setup, include=FALSE}
# User defined variables on each analysis:
# this is the weight for summing in your analysis
hh_wt_field<- 'hh_wt_combined'
# # this is a field to count the number of records
# person_count_field<-'person_dim_id'
# this is how you want to group the data in the first dimension,
# this is how you will get the n for your sub group
group_cat <- 'driver_simp'
# this is the second variable you want to summarize by
var <- 'vehicle_group'
# filter data missing weights
hh_no_na<-person_and_household %>% drop_na(all_of(hh_wt_field))
#filter data missing values
#before you filter out the data, you have to investigate if there are any NAs or missing values in your variables and why they are there.
sum(is.na(person_and_household$household_id)) #0
# now find the sample size of your subgroup
sample_size_group<- hh_no_na %>%
  group_by(driver_simp) %>%
  dplyr::summarize(sample_size = n())
sample_size_group
# get the margins of error for your groups
sample_size_MOE<- categorical_moe(sample_size_group)
# calculate totals and shares
cross_table<-cross_tab_categorical(hh_no_na,group_cat,var, hh_wt_field)
# merge the cross tab with the margin of error
cross_table_w_MOE<-merge(cross_table, sample_size_MOE, by=group_cat)
```

```{r number license : vehicle ownership MOE}
cross_table_w_MOE
```

```{r number license vehicle ownership plot}
# xtabs(~vehicle_group + hhincomeb_reordered, data = person_and_household)
hh_vehcount_licensecount <- person_and_household %>%
  filter(!is.na(driver_simp)) %>%
  group_by(driver_simp,vehicle_group) %>%
  summarise(n=n(), HouseholdWeight = sum(hh_wt_combined))
# hh_vehcount_license 

ggplot(data=hh_vehcount_licensecount, aes(x=driver_simp, y=n, fill= vehicle_group)) +
  geom_bar(stat="identity") +
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5)) +
  labs(x = "Number of Household Licenses", 
       y = "Surveyed Households", 
       fill = "Vehicle Count",
       title = "Vehicle Count by Number of Household Licenses")
```

Reference group: 0 licenses in the household
```{r number license : stats}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$driver_simp)
```

```{r number license : bivariate analysis, results='asis'}
stargazer_table(person_and_household$vehicle_group,
                person_and_household$driver_simp,
                'Vehicle Count by Number of Household Licenses')
```
\
<span style="color:#20b2aa">In reference to the households with no licensed members, households with more licensed drivers are more likely to own more vehicles. This positive association between number of household licenses and household vehicle count is statistically significant.</span>
\
\

#### <span style="color:#009D6A">*5. Number of workers*</span>
This variable is defined as number of household members with 1+ jobs. 

Original data at a household level
```{r numworkers : stats}
# unique(person_and_household$numworkers)
# freq(person_and_household$numworkers)

freq(person_and_household$numworkers)
```
Because there are so few households with more than 4 workers, these households have been grouped together into one category for analysis.
```{r numworkers : simplified}
person_and_household$numworkers <- as.numeric(person_and_household$numworkers)
person_and_household <- person_and_household %>% 
  mutate(numworkers_simp = case_when(numworkers == 5~4,
                                     numworkers == 6~4,
                                     TRUE~.$numworkers))
person_and_household$numworkers_simp <- as.factor(person_and_household$numworkers_simp)
# table(person_and_household$numworkers_simp)
table1(~numworkers_simp, data=person_and_household, render.categorical=my.render.cat)
person_and_household$numworkers_simp <- as.numeric(person_and_household$numworkers_simp)
```

```{r numworkers : MOE setup, include=FALSE}
# User defined variables on each analysis:
# this is the weight for summing in your analysis
hh_wt_field<- 'hh_wt_combined'
# # this is a field to count the number of records
# person_count_field<-'person_dim_id'
# this is how you want to group the data in the first dimension,
# this is how you will get the n for your sub group
group_cat <- 'numworkers_simp'
# this is the second variable you want to summarize by
var <- 'vehicle_group'
# filter data missing weights
hh_no_na<-person_and_household %>% drop_na(all_of(hh_wt_field))
#filter data missing values
#before you filter out the data, you have to investigate if there are any NAs or missing values in your variables and why they are there.
sum(is.na(person_and_household$household_id))
#if you think you need to filter out NAs and missing categories, please use the code below
# hh_no_na = hh_no_na %>%
#   filter(!vehicle_group %in% missing_codes,
#          !is.na(vehicle_group))
# now find the sample size of your subgroup
sample_size_group<- hh_no_na %>%
  group_by(numworkers_simp) %>%
  dplyr::summarize(sample_size = n())
sample_size_group
# get the margins of error for your groups
sample_size_MOE<- categorical_moe(sample_size_group)
# calculate totals and shares
cross_table<-cross_tab_categorical(hh_no_na,group_cat,var, hh_wt_field)
# merge the cross tab with the margin of error
cross_table_w_MOE<-merge(cross_table, sample_size_MOE, by=group_cat)
```

```{r numworkers : vehicle ownership MOE}
cross_table_w_MOE
```

```{r numworkers vehicle ownership plot}
# xtabs(~vehicle_group + hhincomeb_reordered, data = person_and_household)
hh_vehcount_numworkers <- person_and_household %>%
  filter(!is.na(numworkers_simp)) %>%
  group_by(numworkers_simp,vehicle_group) %>%
  summarise(n=n(), HouseholdWeight = sum(hh_wt_combined))
# hh_vehcount_numworkers 

ggplot(data =hh_vehcount_numworkers, aes(x=numworkers_simp, y=n, fill= vehicle_group)) +
  geom_bar(stat="identity") +
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5)) +
  labs(x = "Number of Workers", 
       y = "Survey Responses", 
       fill = "Vehicle Count",
       title = "Vehicle Count by Number of Workers")
```


Reference group: 1 person
```{r numworkers : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$numworkers_simp)
```

```{r numworkers : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group,
                person_and_household$numworkers_simp,
                'Vehicle Count by Number of Workers')
```
\
<span style="color:#20b2aa">In reference to the households with one person, households with more workers are more likely to own more vehicles. This positive association between the number of household workers and household vehicle count is statistically significant.</span>
\
\

#### <span style="color:#009D6A">*6. Number of Jobs*</span>

Original data at a person level (11,940 survey respondents)
```{r jobs : stats}
# unique(person_and_household$jobs)

freq(person$jobs_count)
```
\
The person level jobs data is aggregated to the household level. The following table reflects the sum of the jobs held by individuals within each of the surveyed households (6,319). 
```{r jobs aggregated}
freq(person_and_household$hh_jobs)
```
\
\

##### <span style="color:#486CAB">*Jobs : Worker ratio*</span>
The number of household jobs per worker (sum of household jobs/sum household members with 1+ jobs) was calculated to create a more standardized measurement.  
```{r jobs:workers stats}
# unique(person_and_household$jobs)

summary(person_and_household$jobs_numworkers)
```

```{r jobs workers plot}
# plot histogram
ggplot(person_and_household, aes(jobs_numworkers)) + 
  geom_histogram(bins=30)+
  labs(x = "Jobs:workers Ratio", 
       y = "Surveyed Households")
```

```{r jobs:workers : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$jobs_numworkers)
```

```{r jobs:workers : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group,
                person_and_household$jobs_numworkers,
                'Vehicle Count by jobs:workers ratio')
```
\
<span style="color:#20b2aa">When there are more jobs/workers within a household, these households are more likely to own more vehicles. This positive association between the number of jobs per household worker and household vehicle count is statistically significant.</span>
\
\

#### <span style="color:#009D6A">*7. Educational attainment*</span>
\
Original data at a person level (11,940 survey respondents)
```{r edu}
# freq(person_and_household$license)

# table(person$education)
table1(~education, data=person, render.categorical=my.render.cat)
```
\

##### <span style="color:#486CAB">*Survey education categories*</span>
\
The person level education data is aggregated to the household level. The following tables reflect the lowest and highest educational attainment of the individuals within each of the surveyed households (6,319). The educational attainment categories are ranked based on the number of years of training.
\
\
For example, if a household includes 3 members - one with `Vocational/technical training`, one with a `Bachelor degree`, and one with a `Graduate/post-graduate` degree - the household education minimum would be Vocational/technical training and the household education maximum would be Graduate/post-graduate.

\
**Lowest Educational Attainment**
```{r edu aggregated min}
freq(person_and_household$education_min)
```
\
**Highest Educational Attainment**
```{r edu aggregated max}
freq(person_and_household$education_max)
```
\

###### <span style="color:#B60078">*Household education minimum*</span>
Margin of Error
```{r edu min primary : MOE setup, include=FALSE}
# User defined variables on each analysis:
# this is the weight for summing in your analysis
hh_wt_field<- 'hh_wt_combined'
# # this is a field to count the number of records
# person_count_field<-'person_dim_id'
# this is how you want to group the data in the first dimension,
# this is how you will get the n for your sub group
group_cat <- 'education_min'
# this is the second variable you want to summarize by
var <- 'vehicle_group'
# filter data missing weights
hh_no_na<-person_and_household %>% drop_na(all_of(hh_wt_field))
#filter data missing values
#before you filter out the data, you have to investigate if there are any NAs or missing values in your variables and why they are there.
sum(is.na(person_and_household$household_id)) #0
# now find the sample size of your subgroup
sample_size_group <- hh_no_na %>%
  group_by(education_min) %>%
  dplyr::summarize(sample_size = n())
sample_size_group
# get the margins of error for your groups
sample_size_MOE<- categorical_moe(sample_size_group)
# calculate totals and shares
cross_table<-cross_tab_categorical(hh_no_na,group_cat,var, hh_wt_field)
# merge the cross tab with the margin of error
cross_table_w_MOE<-merge(cross_table, sample_size_MOE, by=group_cat, sort=FALSE)
```

```{r edu min primary : vehicle ownership MOE}
cross_table_w_MOE
```

```{r edu min primary vehicle ownership plot}
hh_vehcount_edumin_pri <- person_and_household %>%
  filter(!is.na(education_min)) %>%
  group_by(education_min,vehicle_group) %>%
  summarise(n=n(), HouseholdWeight = sum(hh_wt_combined))
# hh_vehcount_edumin_pri 

ggplot(data=hh_vehcount_edumin_pri, aes(x=education_min, y=n, fill= vehicle_group)) +
  geom_bar(stat="identity") +
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5)) +
  labs(x = "Lowest Education Attainment", 
       y = "Surveyed Households", 
       fill = "Vehicle Count",
       title = "Vehicle Count by Education attainment (min)")
```

Reference group: Less than high school
```{r edu min primary : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$education_min)
```

```{r edu min primary : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group,
                person_and_household$education_min,
                'Vehicle Count by Lowest educational attainment')
```
\
<span style="color:#20b2aa">In reference to the households with less than a high school degree as the lowest educational attainment, households with less education are more likely to own more vehicles while households with more education ("Bachelor degree" and "Graduate/post-graduate degree") are more likely to own fewer vehicles. This negative association is statistically significant.
\
\
The remaining education categories are either not statistically significant ("Associates degree") or the MOE is high ("Less than high school").</span>
\
\

###### <span style="color:#f75f28">*Analysis check*</span>
Further investigation into the age breakdown of the individuals with "some college" which is not statistically significant, but does show a negative trend, reveals that the majority of individuals with "some college" fall within the age categories: 25-34 and 55-64 - both of which are beyond the typical college age range, taking into account the average 5.1 academic years it takes to complete a four-year degree (https://nscresearchcenter.org/, 2016).
```{r edu : reordered variables, include=FALSE}
# reveal education categories from person table
unique(person$education)
# reorder based on number of years
person$education_reordered <- factor(person$education,
                                     levels=c("Less than high school",
                                              "High school graduate",
                                              "Vocational/technical training",
                                              "Some college",
                                              "Associates degree",
                                              "Bachelor degree",
                                              "Graduate/post-graduate degree",
                                              "Missing: Skip logic")) 
# reveal age categories from person table
unique(person$age)
# reorder based on number of years
person$age_reordered <- factor(person$age,
                               levels=c("Under 5 years old","5-11 years","12-15 years","16-17 years",
                                        "18-24 years","25-34 years","35-44 years","45-54 years",
                                        "55-64 years","65-74 years","75-84 years","85 or years older")) 
```

```{r edu : some college and age distribution table}
table1(~age_reordered | education_reordered, data=person)
```
\
```{r edu some college and age distribution plot}
edu_age_plot <- person %>%
  filter(!is.na(education_reordered)) %>%
  group_by(education_reordered, age_reordered) %>%
  summarise(n=n())

ggplot(edu_age_plot,
       aes(x=age_reordered, y = n, group=education_reordered, color = education_reordered)) + 
  geom_point() +
  geom_line() +
  theme(axis.text.x=element_text(angle = 60, hjust = 1)) +
  labs(x = "Age Categories",
       y = "Survey Responses",
       color = "Educational Attainment",
       title = "Educational Attainment by Age")
```
\
\
```{r edu : vocational-technical hh and veh Count table}
table1(~ as.factor(vehicle_group) |
         education_min,
       data=person_and_household)
```
\
Because individuals with **`Vocational/technical training`** are more likely to have jobs in the specific service professions, this may necessitate the need for a vehicle. Further investigation into vehicle for this subset of the households reveals that households with vocational/technical training make up the highest proportion of households with 2 vehicles (35%) and 3 vehicles (18%). <span style="color:#f75f28">It is important to note that the sample size of households with `Vocational/technical training` as minimum educational attainment represents only 3.4% of the total number of households surveyed.</span>
\
```{r edu min hh and veh ownership plot}
edu_veh_plot <- person_and_household %>%
  filter(!is.na(education_min)) %>%
  group_by(education_min, vehicle_group) %>%
  summarise(n=n()) %>%
  mutate(freq = n / sum(n))

ggplot(edu_veh_plot,
       aes(x=vehicle_group, y = freq, group=education_min, color = education_min)) + 
  geom_point() +
  geom_line() +
  labs(x = "Household Vehicle Count",
       y = "Frequency",
       color = "Educational Attainment",
       title = "Vehicle Count by Educational Attainment (min)")
```
\
\
<span style="color:#20b2aa">The following table provides more detailed information into the relationship between education and a more standardized vehicle count value (**number of household vehicles*/*number of household workers**). Higher values indicate that the households own more vehicles per number of household workers.</span>
```{r edu : min hh and veh ownership by numworkers table}
hh_edu_veh_workers <- person_and_household %>%
  group_by(education_min,vehicle_group, numworkers_simp) %>%
  summarise(veh_numworkers = vehicle_group/numworkers_simp)
  
table1(~ veh_numworkers | education_min,
       data=hh_edu_veh_workers)
```
<span style="color:#20b2aa">This table reveals that almost all households, regardless of minimum education level, own a range of 0-3+ vehicles. Despite this, households with a member holding a vocational/technical degree own the highest average number of vehicles when considering the number of household workers.</span>
\
```{r edu min hh and veh ownership by numworkers plot}
edu_vehworkers_plot <- person_and_household %>%
  dplyr::select(education_min,vehicle_group,numworkers_simp) %>%
  filter(!is.na(education_min)) %>%
  group_by(education_min) %>%
  summarise(veh_numworkers = vehicle_group/numworkers_simp) %>%
  summarise(avg=mean(veh_numworkers)) 

ggplot(edu_vehworkers_plot,
       aes(x=education_min, y = avg, fill=education_min)) + 
  geom_bar(stat='identity') +
  theme(axis.text.x=element_text(angle = 60, hjust = 1)) +
  theme(legend.position = "none") +
  labs(x = "Educational Attainment",
       y = "Household Vehicles:Number of Workers",
       title = "Vehicle Count by Educational Attainment (min)")
```
\
\

###### <span style="color:#B60078">*Household education maximum*</span>
Margin of Error
```{r edu max primary : MOE setup, include=FALSE}
# User defined variables on each analysis:
# this is the weight for summing in your analysis
hh_wt_field<- 'hh_wt_combined'
# # this is a field to count the number of records
# person_count_field<-'person_dim_id'
# this is how you want to group the data in the first dimension,
# this is how you will get the n for your sub group
group_cat <- 'education_max'
# this is the second variable you want to summarize by
var <- 'vehicle_group'
# filter data missing weights
hh_no_na<-person_and_household %>% drop_na(all_of(hh_wt_field))
#filter data missing values
#before you filter out the data, you have to investigate if there are any NAs or missing values in your variables and why they are there.
sum(is.na(person_and_household$household_id)) #0
# now find the sample size of your subgroup
sample_size_group<- hh_no_na %>%
  group_by(education_max) %>%
  dplyr::summarize(sample_size = n())
sample_size_group
# get the margins of error for your groups
sample_size_MOE<- categorical_moe(sample_size_group)
# calculate totals and shares
cross_table<-cross_tab_categorical(hh_no_na,group_cat,var, hh_wt_field)
# merge the cross tab with the margin of error
cross_table_w_MOE<-merge(cross_table, sample_size_MOE, by=group_cat, sort=FALSE)
```

```{r edu max primary : vehicle ownership MOE}
cross_table_w_MOE
```

```{r edu max primary vehicle ownership plot}
hh_vehcount_edumax_pri <- person_and_household %>%
  filter(!is.na(education_max)) %>%
  group_by(education_max,vehicle_group) %>%
  summarise(n=n(), HouseholdWeight = sum(hh_wt_combined))
# hh_vehcount_edumax_pri 

ggplot(data=hh_vehcount_edumax_pri, aes(x=education_max, y=n, fill= vehicle_group)) +
  geom_bar(stat="identity") +
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5)) +
  labs(x = "Highest Education Attainment", 
       y = "Surveyed Households", 
       fill = "Vehicle Count",
       title = "Vehicle Count by Education attainment (max)")
```

Reference group: Less than high school
```{r edu max primary : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$education_max)
```

```{r edu max primary : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group,
                person_and_household$education_max,
                'Vehicle Count by Highest educational attainment')
```
\
<span style="color:#20b2aa">In reference to the households with less than a high school degree as the highest educational attainment, households with fewest years of educational training ("High school graduate", "Vocational/technical training", and "Some college") are likely to own fewer vehicles, while households with more education ("Associates degree", "Bachelor degree", and "Graduate/post-graduate") are likely to own more vehicles. These results are statistically significant and reveal a general linear trend.</span>
\
\
```{r edu max hh and veh Count plot}
edu_veh_plot <- person_and_household %>%
  filter(!is.na(education_max)) %>%
  group_by(education_max, vehicle_group) %>%
  summarise(n=n()) %>%
  mutate(freq = n / sum(n))

ggplot(edu_veh_plot,
       aes(x=vehicle_group, y = freq, group=education_max, color = education_max)) + 
  geom_point() +
  geom_line() +
  labs(x = "Household Vehicle",
       y = "Frequency",
       color = "Educational Attainment",
       title = "Vehicle Count by Educational Attainment (max)")
```
\
\
<span style="color:#20b2aa">The following table provides more detailed information into the relationship between education and a more standardized vehicle count value (**number of household vehicles*/*number of household workers**). Higher values indicate that the households own more vehicles per number of household workers.</span>
```{r edu : max hh and veh ownership by numworkers table}
hh_edu_veh_workers <- person_and_household %>%
  group_by(education_max,vehicle_group, numworkers_simp) %>%
  summarise(veh_numworkers = vehicle_group/numworkers_simp)
  
table1(~ veh_numworkers | education_max,
       data=hh_edu_veh_workers)
```
<span style="color:#20b2aa">This table reveals that most households, regardless of maximum education level, own a range of 0-3+ vehicles. Households with a member holding an associates degree as the highest educational attainment own the highest average number of vehicles when considering the number of household workers. Households with a member having less than a high school degree as the highest educational attainment own the fewest vehicles per number of workers. It is important to note that the standard deviations are relatively high.</span>
\
\
```{r edu max hh and veh ownership by numworkers plot}
edu_vehworkers_plot <- person_and_household %>%
  dplyr::select(education_max,vehicle_group,numworkers_simp) %>%
  filter(!is.na(education_max)) %>%
  group_by(education_max) %>%
  summarise(veh_numworkers = vehicle_group/numworkers_simp) %>%
  summarise(avg=mean(veh_numworkers)) 

ggplot(edu_vehworkers_plot,
       aes(x=education_max, y = avg, fill=education_max)) + 
  geom_bar(stat='identity') +
  theme(axis.text.x=element_text(angle = 60, hjust = 1)) +
  theme(legend.position = "none") +
  labs(x = "Educational Attainment",
       y = "Household Vehicles:Number of Workers",
       title = "Vehicle Count by Educational Attainment (max)")
```
\
```{r edu max hh and veh ownership by numworkers - all households plot}
edu_allvehworkers_plot <- person_and_household %>%
  group_by(education_max,vehicle_group,numworkers_simp) %>%
  filter(!is.na(education_max)) %>%
  summarise(veh_numworkers = vehicle_group/numworkers_simp)

ggplot(edu_allvehworkers_plot,
       aes(x=vehicle_group, y = numworkers_simp, color=education_max)) + 
  geom_jitter(stat = "identity", width=0.4, height=0.4, alpha=0.15) +
  theme(axis.text.x=element_text(angle = 0, hjust = 0.5)) +
  #facet_grid(.~education_max) +
  #theme(legend.position = "none") +
  labs(x = "Household Vehicles",
       y = "Household Vehicles:Number of Workers",
       color = "Educational Attainment",
       title = "Vehicle Count by Educational Attainment (max)")
```
\
\


##### <span style="color:#486CAB">*Simplified education categories*</span>
These education attainment categories have been simplified into the following 4 categories:

* high school or less
* vocational, associates, less than 4 years of college
* bachelor degree
* post-graduate

```{r edu : simplified, include=FALSE}
person_and_household$education_min <- as.character(person_and_household$education_min)
person_and_household$education_max <- as.character(person_and_household$education_max)
person_and_household <- person_and_household %>%
  mutate(hh_edu_min_simp = case_when(education_min=="Less than high school" |
                                       education_min=="High school graduate"~ "High school",
                                     education_min=="Vocational/technical training" |
                                       education_min=="Associates degree" |
                                       education_min=="Some college" ~ "Specialized, <4y",
                                     education_min=="Graduate/post-graduate degree" ~"Post-graduate",
                                       TRUE~.$education_min)) %>%
  mutate(hh_edu_max_simp = case_when(education_max=="Less than high school" |
                                       education_max=="High school graduate"~ "High school",
                                     education_max=="Vocational/technical training" |
                                       education_max=="Associates degree" |
                                       education_max=="Some college" ~ "Specialized, <4y",
                                     education_max=="Graduate/post-graduate degree" ~"Post-graduate",
                                       TRUE~.$education_max))

person_and_household$hh_edu_min_simp <- factor(person_and_household$hh_edu_min_simp,
                                     levels=c("High school",
                                              "Specialized, <4y",
                                              "Bachelor degree",
                                              "Post-graduate"))
person_and_household$hh_edu_max_simp <- factor(person_and_household$hh_edu_max_simp,
                                     levels=c("High school",
                                              "Specialized, <4y",
                                              "Bachelor degree",
                                              "Post-graduate"))
```
\
**Lowest Simplified Educational Attainment**
```{r edu aggregated min simp}
freq(person_and_household$hh_edu_min_simp)
```
\
**Highest Simplified Educational Attainment**
```{r edu aggregated max simp}
freq(person_and_household$hh_edu_max_simp)
```
\

###### <span style="color:#B60078">*Simp. household education minimum*</span>
Margin of Error
```{r edu min simp : MOE setup, include=FALSE}
# User defined variables on each analysis:
# this is the weight for summing in your analysis
hh_wt_field<- 'hh_wt_combined'
# # this is a field to count the number of records
# person_count_field<-'person_dim_id'
# this is how you want to group the data in the first dimension,
# this is how you will get the n for your sub group
group_cat <- 'hh_edu_min_simp'
# this is the second variable you want to summarize by
var <- 'vehicle_group'
# filter data missing weights
hh_no_na<-person_and_household %>% drop_na(all_of(hh_wt_field))
#filter data missing values
#before you filter out the data, you have to investigate if there are any NAs or missing values in your variables and why they are there.
sum(is.na(person_and_household$household_id)) #0
# now find the sample size of your subgroup
sample_size_group <- hh_no_na %>%
  group_by(hh_edu_min_simp) %>%
  dplyr::summarize(sample_size = n())
sample_size_group
# get the margins of error for your groups
sample_size_MOE<- categorical_moe(sample_size_group)
# calculate totals and shares
cross_table<-cross_tab_categorical(hh_no_na,group_cat,var, hh_wt_field)
# merge the cross tab with the margin of error
cross_table_w_MOE<-merge(cross_table, sample_size_MOE, by=group_cat, sort=FALSE)
```

```{r edu min simp : vehicle ownership MOE}
cross_table_w_MOE
```

```{r edu min simp vehicle ownership plot}
hh_vehcount_edumin <- person_and_household %>%
  filter(!is.na(hh_edu_min_simp)) %>%
  group_by(hh_edu_min_simp,vehicle_group) %>%
  summarise(n=n(), HouseholdWeight = sum(hh_wt_combined))
# hh_vehcount_edumin 

ggplot(data=hh_vehcount_edumin, aes(x=hh_edu_min_simp, y=n, fill= vehicle_group)) +
  geom_bar(stat="identity") +
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5)) +
  labs(x = "Lowest Education Attainment", 
       y = "Surveyed Households", 
       fill = "Vehicle Count",
       title = "Vehicle Count by simplified education attainment (min)")
```

Reference group: High school
```{r edu min simp : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$hh_edu_min_simp)
```

```{r edu min simp : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group,
                person_and_household$hh_edu_min_simp,
                'Vehicle Count by Lowest educational attainment (simplified)')
```
\
<span style="color:#20b2aa">In reference to the households with a high school degree as the lowest educational attainment, households with more education (post-graduate) are less likely to own more vehicles, while those with less education are more likely to own more vehicles. This negative association between educational attainment (min) and household vehicle count is statistically significant.</span>
\
\

###### <span style="color:#B60078">*Simp. household education maximum*</span>
Margin of Error
```{r edu max simp : MOE setup, include=FALSE}
# User defined variables on each analysis:
# this is the weight for summing in your analysis
hh_wt_field<- 'hh_wt_combined'
# # this is a field to count the number of records
# person_count_field<-'person_dim_id'
# this is how you want to group the data in the first dimension,
# this is how you will get the n for your sub group
group_cat <- 'hh_edu_max_simp'
# this is the second variable you want to summarize by
var <- 'vehicle_group'
# filter data missing weights
hh_no_na<-person_and_household %>% drop_na(all_of(hh_wt_field))
#filter data missing values
#before you filter out the data, you have to investigate if there are any NAs or missing values in your variables and why they are there.
sum(is.na(person_and_household$household_id)) #0
# now find the sample size of your subgroup
sample_size_group<- hh_no_na %>%
  group_by(hh_edu_max_simp) %>%
  dplyr::summarize(sample_size = n())
sample_size_group
# get the margins of error for your groups
sample_size_MOE<- categorical_moe(sample_size_group)
# calculate totals and shares
cross_table<-cross_tab_categorical(hh_no_na,group_cat,var, hh_wt_field)
# merge the cross tab with the margin of error
cross_table_w_MOE<-merge(cross_table, sample_size_MOE, by=group_cat, sort=FALSE)
```

```{r edu max simp : vehicle ownership MOE}
cross_table_w_MOE
```

```{r edu max simp vehicle ownership plot}
hh_vehcount_edumax <- person_and_household %>%
  filter(!is.na(hh_edu_max_simp)) %>%
  group_by(hh_edu_max_simp,vehicle_group) %>%
  summarise(n=n(), HouseholdWeight = sum(hh_wt_combined))
# hh_vehcount_edumax 

ggplot(data=hh_vehcount_edumax, aes(x=hh_edu_max_simp, y=n, fill= vehicle_group)) +
  geom_bar(stat="identity") +
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5)) +
  labs(x = "Highest Education Attainment", 
       y = "Surveyed Households", 
       fill = "Vehicle Count",
       title = "Vehicle Count by simplified education attainment (max)")
```

Reference group: High school
```{r edu max simp : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$hh_edu_max_simp)
```

```{r edu max simp : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group,
                person_and_household$hh_edu_max_simp,
                'Vehicle Count by Highest educational attainment (simplified)')
```
\
<span style="color:#20b2aa">In reference to the households with a high school degree as the highest educational attainment, households with more education (post-graduate) are more likely to own more vehicles, while those with high school or less are less likely to own more vehicles. This positive association between educational attainment (max) and household vehicle count is statistically significant.</span>
\
\

#### <span style="color:#009D6A">*8. Race*</span>
The household travel survey asked participants about the race of adults in each household, with no children in households assigned to any racial group.
\
Original data at a person level (11,940 survey respondents).
```{r person-level race : stats}
# table(person_and_household$hh_race_category)
table1(~race_category, data=person, render.categorical=my.render.cat)
```
\
The person level race data is aggregated to the household level (6,319) based on the following logic:  

1. Households were grouped into single racial groups alone based on the identified race of the individual members (i.e. African American alone, Asian alone, Hispanic alone, etc.), as well as a category for households with members of different races 
\
```{r hh race : stats}
# table(person_and_household$hh_race_category)
table1(~hh_race_category, data=person_and_household, render.categorical=my.render.cat)
```
\
2. Other than Asian and Non-Hispanic White, the groups were too small to report, and were therefore combined together into categories large enough to achieve statistically valid sample sizes. Survey participants could choose not to select any choice for race; households with any adults missing race were assigned to a Missing group. The "Missing/Other" group includes households categorized as "Missing" or "Other."
\

Three groups are shown in the analysis below: 

* A composite of households where all adults are African American, Hispanic, or Native American, and households with non-White adults of multiple races
* Households where all adults are Asian alone
* Households where all adults are Non-Hispanic White alone
\

##### <span style="color:#486CAB">*White Only, Asian, and other POC households*</span>
White only (7,147), Asian (2,141), other POC (935), and missing/other (1,717).
```{r race expanded categories : setup, include = FALSE}
person_and_household <- person_and_household %>%
  mutate(hh_race_3 = case_when(hh_race_category == "White Only" ~ "White Only",
                               hh_race_category == "Missing" | hh_race_category == "Other" ~ "Missing/Other",
                               hh_race_category == "Asian" ~ "Asian",
                               TRUE ~ "People of Color"))
# table(person_and_household$hh_race_3)
table1(~hh_race_3, data=person_and_household, render.categorical=my.render.cat)

person_and_household$hh_race_3 <- factor(person_and_household$hh_race_3,
                                         levels = c("White Only", "People of Color", "Asian", "Missing/Other"))
``` 

```{r race expanded : MOE setup, include=FALSE}
# User defined variables on each analysis:
# this is the weight for summing in your analysis
hh_wt_field<- 'hh_wt_combined'
# # this is a field to count the number of records
# person_count_field<-'person_dim_id'
# this is how you want to group the data in the first dimension,
# this is how you will get the n for your sub group
group_cat <- 'hh_race_3' 
# this is the second variable you want to summarize by
var <- 'vehicle_group'
# filter data missing weights
hh_no_na<-person_and_household %>% drop_na(all_of(hh_wt_field))
# filter data missing values
# before you filter out the data, you have to investigate if there are any NAs or missing values in your variables and why they are there.
sum(is.na(household$household_id))
# if you think you need to filter out NAs and missing categories, please use the code below
# hh_no_na = hh_no_na %>%
#   filter(!hh_race_2 %in% missing_codes,
#          !is.na(hh_race_2))
# now find the sample size of your subgroup
sample_size_group<- hh_no_na %>%
  group_by(hh_race_3) %>%
  dplyr::summarize(sample_size = n())
sample_size_group
# get the margins of error for your groups
sample_size_MOE<- categorical_moe(sample_size_group)
# calculate totals and shares
cross_table<-cross_tab_categorical(hh_no_na,group_cat,var, hh_wt_field)
# merge the cross tab with the margin of error
cross_table_w_MOE<-merge(cross_table, sample_size_MOE, by=group_cat)
```

```{r race expanded : vehicle ownership MOE}
cross_table_w_MOE
```
\
Reference group: White Only
```{r race expanded: bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$hh_race_3)
```

```{r race expanded : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group, 
                person_and_household$hh_race_3,
                "Vehicle Count by Race")
```
\
<span style="color:#20b2aa">The relationship between race and household vehicle count is statistically significant for Asian households. POC households show a similar trend - owning fewer vehicles than white households - but the relationship is not significant. This is likely because of the small sample size of POC households, excluding Asian households (less than 10% of the sample: 467/6,319). This indicates that the White Only and POC household analysis is largely based on Asian households (~16%: 1,024/6,319).</span>
\
\

##### <span style="color:#486CAB">*Alternative: White Only and POC households*</span>
Because of the small numbers of respondents identifying as non-white, these groups have been grouped together as "POC" - including households with individuals who identified as "African American," "Asian", and "Hispanic." 
```{r race : setup, include=FALSE}
# simplify race category 
person_and_household <- person_and_household %>% 
  mutate(hh_race_2 = case_when(hh_race_category == "White Only" ~ 'White Only',
                               hh_race_category == "Missing" | hh_race_category == "Other" ~ "Missing/Other",
                               TRUE ~ "People of Color")) 
#POC = African American, Asian, Hispanic
freq(person_and_household$hh_race_2) #requries summarytools

# # remove missing/other category
# person_and_household <- person_and_household %>%
#   filter(hh_race_2 != "Missing/Other")
# freq(person_and_household$hh_race_2)
```

```{r race : descriptive stats table}
# person_and_household %>%
#   group_by(hh_race_category, hh_race_2) %>%
#   tally()
# table(person_and_household$hh_race_2)
table1(~hh_race_2, data=person_and_household, render.categorical=my.render.cat)

person_and_household$hh_race_2 <- factor(person_and_household$hh_race_2,
                                         levels = c("White Only", "People of Color", "Missing/Other"))
```
\
```{r race : MOE setup, include=FALSE}
# User defined variables on each analysis:
# this is the weight for summing in your analysis
hh_wt_field<- 'hh_wt_combined'
# # this is a field to count the number of records
# person_count_field<-'person_dim_id'
# this is how you want to group the data in the first dimension,
# this is how you will get the n for your sub group
group_cat <- 'hh_race_2'
# this is the second variable you want to summarize by
var <- 'vehicle_group'
# filter data missing weights
hh_no_na<-person_and_household %>% drop_na(all_of(hh_wt_field))
#filter data missing values
#before you filter out the data, you have to investigate if there are any NAs or missing values in your variables and why they are there.
sum(is.na(person_and_household$household_id))
#if you think you need to filter out NAs and missing categories, please use the code below
# hh_no_na = hh_no_na %>%
#   filter(!hh_race_2 %in% missing_codes,
#          !is.na(hh_race_2))
# now find the sample size of your subgroup
sample_size_group<- hh_no_na %>%
  group_by(hh_race_2) %>%
  dplyr::summarize(sample_size = n())
sample_size_group
# get the margins of error for your groups
sample_size_MOE<- categorical_moe(sample_size_group)
# calculate totals and shares
cross_table<-cross_tab_categorical(hh_no_na,group_cat,var, hh_wt_field)
# merge the cross tab with the margin of error
cross_table_w_MOE<-merge(cross_table, sample_size_MOE, by=group_cat)
```

```{r race : vehicle ownership MOE}
cross_table_w_MOE
```
\
```{r race vehicle ownership plot}
# xtabs(~vehicle_group + hh_race_2, data = person_and_household)
hh_vehcount_race <- person_and_household %>%
  filter(!is.na(hh_race_2)) %>%
  group_by(hh_race_2,vehicle_group) %>%
  summarise(n=n(), HouseholdWeight = sum(hh_wt_combined))
# hh_vehcount_race

ggplot(data = hh_vehcount_race, aes(x=hh_race_2, y=n, fill= vehicle_group)) +
  geom_bar(stat="identity") +
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5)) +
  labs(x = "Race",
       y = "Survey Responses",
       fill = "Vehicle Count",
       title = "Vehicle Count by Race")
```

Reference group: White Only
```{r race : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$hh_race_2)
```

```{r race : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group, 
                 person_and_household$hh_race_2,
                "Vehicle Count by Race")
```
\
<span style="color:#20b2aa">The relationship between race and household vehicle count is statistically significant with POC households owning fewer vehicles.</span>
\
\

#### <span style="color:#009D6A">*9. Housing*</span>
This category can be analyzed at two different levels: 

* housing tenure (rent vs. own)  
* residential type  

##### <span style="color:#486CAB">*Housing tenure*</span>
```{r tenure : stats}
# freq(person_and_household$rent_own)
# table(person_and_household$rent_own)
table1(~rent_own, data=person_and_household, render.categorical=my.render.cat)
```
\
Because the majority of respondents identify as renters or owners, the other categories with fewer responses were grouped together. 
```{r tenure : setup}
person_and_household <- person_and_household %>% 
  mutate(rent_own_simp = case_when(rent_own == "Prefer not to answer" | 
                                    rent_own == "Other" |
                                    rent_own == "Provided by job or military" ~ "Other",
                                  TRUE~.$rent_own))

person_and_household$rent_own_simp <- factor(person_and_household$rent_own_simp, 
                                            levels=c("Own/paying mortgage",
                                                     "Rent",
                                                     "Other"))
# freq(person_and_household$rent_own_simp)
# table(person_and_household$rent_own_simp)
table1(~rent_own_simp, data=person_and_household, render.categorical=my.render.cat)
```

```{r tenure : MOE setup, include=FALSE}
# User defined variables on each analysis:
# this is the weight for summing in your analysis
hh_wt_field<- 'hh_wt_combined'
# # this is a field to count the number of records
# person_count_field<-'person_dim_id'
# this is how you want to group the data in the first dimension,
# this is how you will get the n for your sub group
group_cat <- 'rent_own_simp'
# this is the second variable you want to summarize by
var <- 'vehicle_group'
# filter data missing weights
hh_no_na<-person_and_household %>% drop_na(all_of(hh_wt_field))
#filter data missing values
#before you filter out the data, you have to investigate if there are any NAs or missing values in your variables and why they are there.
sum(is.na(household$household_id))
#if you think you need to filter out NAs and missing categories, please use the code below
# hh_no_na = hh_no_na %>%
#   filter(!hh_lifecycle %in% missing_codes,
#          !is.na(hh_lifecycle))
# now find the sample size of your subgroup
sample_size_group<- hh_no_na %>%
  group_by(rent_own_simp) %>%
  dplyr::summarize(sample_size = n())
sample_size_group
# get the margins of error for your groups
sample_size_MOE<- categorical_moe(sample_size_group)
# calculate totals and shares
cross_table<-cross_tab_categorical(hh_no_na,group_cat,var, hh_wt_field)
# merge the cross tab with the margin of error
cross_table_w_MOE<-merge(cross_table, sample_size_MOE, by=group_cat)
```

```{r tenure : vehicle ownership MOE}
cross_table_w_MOE
```

```{r tenure vehicle ownership plot}
# xtabs(~vehicle_group + hh_vehcount_rentown, data = person_and_household)
hh_vehcount_rentown <- person_and_household %>%
  filter(!is.na(rent_own_simp)) %>%
  group_by(rent_own_simp,vehicle_group) %>%
  summarise(n=n(), HouseholdWeight = sum(hh_wt_combined))
# hh_vehcount_rentown 

ggplot(data = hh_vehcount_rentown, aes(x=rent_own_simp, y=n, fill= vehicle_group)) +
  geom_bar(stat="identity") +
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5)) +
  labs(x = "Household Tenure", 
       y = "Survey Responses", 
       fill = "Vehicle Count",
       title = "Vehicle Count by Household Tenure")
```

Reference group: Own/paying mortgage
```{r tenure : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$rent_own_simp)
```

```{r tenure : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group, 
                 person_and_household$rent_own_simp,
                "Vehicle Count by Household Tenure")
```
\
<span style="color:#20b2aa">The relationship between household tenure and household vehicle count is statistically significant, with renting individuals reporting that they are part of households that own fewer vehicles.</span>
\
\

##### <span style="color:#486CAB">*Housing type*</span>
```{r housing type : stats}
# freq(person_and_household$res_type)
# table(person_and_household$res_type)
table1(~res_type, data=person_and_household, render.categorical=my.render.cat)
```
\
Because the majority of respondents identify as living in apartment buildings or single-family detached houses, the survey responses have been simplified and recategorized. 
```{r housing type : setup}
person_and_household <- person_and_household %>% 
  mutate(restype_simp = case_when(res_type == "Mobile home/trailer" | 
                                    res_type == "Dorm or institutional housing" |
                                    res_type == "Other (including boat, RV, van, etc.)" ~ "Other",
                                  res_type == "Building with 3 or fewer apartments/condos" |
                                    res_type == "Building with 4 or more apartments/condos" ~ "Apartment/condo",
                                  res_type == "Single-family house (detached house)" ~ "Single-family",
                                  res_type == "Townhouse (attached house)" ~ "Townhouse",
                                  TRUE~.$res_type))

# freq(person_and_household$restype_simp)
# table(person_and_household$restype_simp)
table1(~restype_simp, data=person_and_household, render.categorical=my.render.cat)
```

```{r housing type : MOE setup, include=FALSE}
# User defined variables on each analysis:
# this is the weight for summing in your analysis
hh_wt_field<- 'hh_wt_combined'
# # this is a field to count the number of records
# person_count_field<-'person_dim_id'
# this is how you want to group the data in the first dimension,
# this is how you will get the n for your sub group
group_cat <- 'restype_simp'
# this is the second variable you want to summarize by
var <- 'vehicle_group'
# filter data missing weights
hh_no_na<-person_and_household %>% drop_na(all_of(hh_wt_field))
#filter data missing values
#before you filter out the data, you have to investigate if there are any NAs or missing values in your variables and why they are there.
sum(is.na(household$household_id))
#if you think you need to filter out NAs and missing categories, please use the code below
# hh_no_na = hh_no_na %>%
#   filter(!hh_lifecycle %in% missing_codes,
#          !is.na(hh_lifecycle))
# now find the sample size of your subgroup
sample_size_group<- hh_no_na %>%
  group_by(restype_simp) %>%
  dplyr::summarize(sample_size = n())
sample_size_group
# get the margins of error for your groups
sample_size_MOE<- categorical_moe(sample_size_group)
# calculate totals and shares
cross_table<-cross_tab_categorical(hh_no_na,group_cat,var, hh_wt_field)
# merge the cross tab with the margin of error
cross_table_w_MOE<-merge(cross_table, sample_size_MOE, by=group_cat)
```

```{r housing type : vehicle ownership MOE}
cross_table_w_MOE
```

```{r housing type vehicle ownership plot}
# xtabs(~vehicle_group + hh_vehcount_rentown, data = person_and_household)
hh_vehcount_housetype <- person_and_household %>%
  filter(!is.na(restype_simp)) %>%
  group_by(restype_simp,vehicle_group) %>%
  summarise(n=n(), HouseholdWeight = sum(hh_wt_combined))

ggplot(data = hh_vehcount_housetype, aes(x=restype_simp, y=n, fill= vehicle_group)) +
  geom_bar(stat="identity") +
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5)) +
  labs(x = "Household Type", 
       y = "Survey Responses", 
       fill = "Vehicle Count",
       title = "Vehicle Count by Household Type")
```

Reference group: Apartment/condo
```{r housing type : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$restype_simp)
```

```{r housing type : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group, 
                 person_and_household$restype_simp,
                "Vehicle Count by Household Type")
```
\
<span style="color:#20b2aa">The relationship between household type and household vehicle counts is statistically significant, with single-family (detached) households reporting highest vehicle counts. Households in townhomes (attached) report higher vehicle counts than those in apartments or condos, but lower vehicle counts than those in single-family houses.</span>
\
\

#### <span style="color:#009D6A">*10. Housing location*</span>
This measurement will analyze housing location in relation to regional growth centers (RGCs). According to PSRC's VISION 2050 planning process: "The region has designated 29 regional growth centers. These are locations of the region’s most significant business, governmental, and cultural facilities and are planning for growth." More information is available at https://www.psrc.org/centers.   
\

```{r RGC : stats}
freq(person_and_household$final_home_rgcnum)
```
\
TO simplify analysis, the 29 RGCs are categorized together.
```{r RGC : setup}
person_and_household <- person_and_household %>%
  mutate(RGC_binary = case_when(final_home_rgcnum == "Not RCG" ~ "Not RGC",
                                TRUE ~ "RGC"))

# freq(person_and_household$RGC_binary)
table1(~RGC_binary, data = person_and_household)
```

```{r RGC : MOE setup, include=FALSE}
# User defined variables on each analysis:
# this is the weight for summing in your analysis
hh_wt_field<- 'hh_wt_combined'
# # this is a field to count the number of records
# person_count_field<-'person_dim_id'
# this is how you want to group the data in the first dimension,
# this is how you will get the n for your sub group
group_cat <- 'RGC_binary'
# this is the second variable you want to summarize by
var <- 'vehicle_group'
# filter data missing weights
hh_no_na<-person_and_household %>% drop_na(all_of(hh_wt_field))
#filter data missing values
#before you filter out the data, you have to investigate if there are any NAs or missing values in your variables and why they are there.
sum(is.na(household$household_id))
#if you think you need to filter out NAs and missing categories, please use the code below
# hh_no_na = hh_no_na %>%
#   filter(!hh_lifecycle %in% missing_codes,
#          !is.na(hh_lifecycle))
# now find the sample size of your subgroup
sample_size_group<- hh_no_na %>%
  group_by(RGC_binary) %>%
  dplyr::summarize(sample_size = n())
sample_size_group
# get the margins of error for your groups
sample_size_MOE<- categorical_moe(sample_size_group)
# calculate totals and shares
cross_table<-cross_tab_categorical(hh_no_na,group_cat,var, hh_wt_field)
# merge the cross tab with the margin of error
cross_table_w_MOE<-merge(cross_table, sample_size_MOE, by=group_cat)
```

```{r RGC : vehicle ownership MOE}
cross_table_w_MOE
```

```{r RGC vehicle ownership plot}
# xtabs(~vehicle_group + hh_vehcount_rentown, data = person_and_household)
hh_vehcount_RGC <- person_and_household %>%
  filter(!is.na(RGC_binary)) %>%
  group_by(RGC_binary,vehicle_group) %>%
  summarise(n=n(), HouseholdWeight = sum(hh_wt_combined))

ggplot(data = hh_vehcount_RGC, aes(x=RGC_binary, y=n, fill= vehicle_group)) +
  geom_bar(stat="identity") +
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5)) +
  labs(x = "Housing Location", 
       y = "Survey Responses", 
       fill = "Vehicle Count",
       title = "Vehicle Count by RGC")
```

Reference group: Not RGC
```{r RGC : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$RGC_binary)
```

```{r RGC : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group, 
                 person_and_household$RGC_binary,
                "Vehicle Count by RGC")
```
\
<span style="color:#20b2aa">Households located in RGCs report lower vehicle counts than those living outside of RGCs. This is statistically significant.</span>
\
\

#### <span style="color:#009D6A">*11. Commute patterns*</span>
There are 4 commute-related variables. The first three were originally collected at the person level and the last was calculated at the household-level:

* Distance (mi) by automobile
* Time (min) by automobile
* Commute frequency (days/week)
* Number of household commute trips per week
\

##### <span style="color:#486CAB">*Commute Distance*</span>
Original data at a person level (11,940 survey respondents)
```{r commuting auto distance stats}
summary(person$commute_auto_distance) #very high MAX values
```

```{r commuting auto distance person-level plot}
# plot histogram
ggplot(person, aes(commute_auto_distance)) + 
  geom_histogram(bins=30)+
  labs(x = "Reported Commute Distance (mi)", 
       y = "Surveyed Respondents")
```
\
These statistics show outliers within the dataset. **These outliers have not yet been removed.** 
\
\
The person level commute distance data is aggregated to the household level (6,319):  

* the average commute distance (mi) of the household individuals
* the total commute distance (mi) of the household individuals
\

###### <span style="color:#B60078">*Commute distance (average)*</span>
```{r commuting auto distance average plot}
# plot histogram
ggplot(person_and_household, aes(hh_com_auto_dist_avg)) + 
  geom_histogram(bins=30)+
  labs(x = "Average Commute Distance (mi)", 
       y = "Surveyed Households")
```

```{r commuting auto distance average : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$hh_com_auto_dist_avg)
```

```{r commuting auto distance average : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group, 
                 person_and_household$hh_com_auto_dist_avg,
                "Vehicle Count by Average Commute Distance")
```
\
There are fewer observations because of the 4,174 NA values - a result of using the `mean()`.  
\
\

###### <span style="color:#B60078">*Commute distance (total)*</span>
```{r commuting auto distance sum plot}
# plot histogram
ggplot(person_and_household, aes(hh_com_auto_dist_sum)) + 
  geom_histogram(bins=30)+
  labs(x = "Total Commute Distance (mi)", 
       y = "Surveyed Households")
```

```{r commuting auto distance sum : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$hh_com_auto_dist_sum)
```

```{r commuting auto distance sum : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group, 
                 person_and_household$hh_com_auto_dist_sum,
                "Vehicle Count by Total Commute Distance")
```
\
<span style="color:#20b2aa">Both average household commute distance and the total household commute distance are positively associated with household vehicle counts. Although the coefficients are small, these variables are statistically significant.</span>
\
\

##### <span style="color:#486CAB">*Commute Time*</span>
Original data at a person level (11,940 survey respondents)
```{r commuting auto time}
summary(person$commute_auto_time) #very high MAX values
```

```{r commuting auto time person-level plot}
# plot histogram
ggplot(person, aes(commute_auto_time)) + 
  geom_histogram(bins=30)+
  labs(x = "Reported Commute Time (min)", 
       y = "Surveyed Respondents")
```
\
These statistics show outliers within the dataset. **These outliers have not yet been removed.**
\
\
The person level commute distance data is aggregated to the household level (6,319):  

* the average commute time (min) of the household individuals
* the total commute time (mi) of the household individuals
\

###### <span style="color:#B60078">*Commute time (average)*</span>
```{r commuting auto time average plot}
# plot histogram
ggplot(person_and_household, aes(hh_com_auto_time_avg)) + 
  geom_histogram(bins=30)+
  labs(x = "Average Commute Time (min)", 
       y = "Surveyed Households")
```

```{r commuting auto time average : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$hh_com_auto_time_avg)
```

```{r commuting auto time average : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group, 
                 person_and_household$hh_com_auto_time_avg,
                "Vehicle Count by Average Commute Time")
```
\
There are fewer observations because of the 4,174 NA values - a result of using the `mean()`.  
\
\

###### <span style="color:#B60078">*Commute time (total)*</span>
```{r commuting auto time total plot}
# plot histogram
ggplot(person_and_household, aes(hh_com_auto_time_sum)) + 
  geom_histogram(bins=30)+
  labs(x = "Average Commute Time (min)", 
       y = "Surveyed Households")
```

```{r commuting auto time total : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$hh_com_auto_time_sum)
```

```{r commuting auto time total : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group, 
                 person_and_household$hh_com_auto_time_sum,
                "Vehicle Count by Total Commute Time")
```
\
<span style="color:#20b2aa">Both average household commute time and the total household commute time are positively associated with household vehicle count. Although the coefficients are small, these variables are statistically significant.</span> 
\
\


##### <span style="color:#486CAB">*Commute Frequency*</span>
Original data at a person level (11,940 survey respondents)
```{r commuting frequency stats}
# freq(person$commute_freq)
table1(~commute_freq, data=person, render.categorical=my.render.cat)
```
\

###### <span style="color:#B60078">*Survey commute frequency*</span>
The commuting frequency data is aggregated to the household level. The following tables reflect the lowest and highest commuting frequencies of the individuals within each of the surveyed households (6,319).
\

**Lowest commuting frequencies**
```{r commuting frequency aggregated min}
freq(person_and_household$commute_freq_min)
```
\
**Highest commuting frequencies**
```{r commuting frequency aggregated max}
freq(person_and_household$commute_freq_max)
```
\

###### <span style="color:#f75f28">*Commute frequency (min)*</span>
Margin of Error
```{r commuting frequency min : MOE setup, include=FALSE}
# User defined variables on each analysis:
# this is the weight for summing in your analysis
hh_wt_field<- 'hh_wt_combined'
# # this is a field to count the number of records
# person_count_field<-'person_dim_id'
# this is how you want to group the data in the first dimension,
# this is how you will get the n for your sub group
group_cat <- 'commute_freq_min'
# this is the second variable you want to summarize by
var <- 'vehicle_group'
# filter data missing weights
hh_no_na<-person_and_household %>% drop_na(all_of(hh_wt_field))
#filter data missing values
#before you filter out the data, you have to investigate if there are any NAs or missing values in your variables and why they are there.
sum(is.na(person_and_household$household_id)) #0
# now find the sample size of your subgroup
sample_size_group<- hh_no_na %>%
  group_by(commute_freq_min) %>%
  dplyr::summarize(sample_size = n())
sample_size_group
# get the margins of error for your groups
sample_size_MOE<- categorical_moe(sample_size_group)
# calculate totals and shares
cross_table<-cross_tab_categorical(hh_no_na,group_cat,var, hh_wt_field)
# merge the cross tab with the margin of error
cross_table_w_MOE<-merge(cross_table, sample_size_MOE, by=group_cat)
```

```{r commuting frequency min : vehicle ownership MOE}
cross_table_w_MOE
```

```{r commuting frequency min vehicle ownership plot}
hh_vehcount_commutefreqmin_all <- person_and_household %>%
  filter(!is.na(commute_freq_min)) %>%
  group_by(commute_freq_min, vehicle_group) %>%
  summarise(n=n(), HouseholdWeight = sum(hh_wt_combined))
# hh_vehcount_commutefreqmin_all 

ggplot(data=hh_vehcount_commutefreqmin_all, aes(x=commute_freq_min, y=n, fill= vehicle_group)) +
  geom_bar(stat="identity") +
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5)) +
  labs(x = "Commute Frequency (min)", 
       y = "Surveyed Households", 
       fill = "Vehicle Count",
       title = "Vehicle Count by Commuting Frequency (min)")
```

Reference group: 1 day a week
```{r commuting frequency min : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$commute_freq_min)
```

```{r commuting frequency min : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group,
                person_and_household$commute_freq_min,
                'Vehicle Count by Commuting Frequency (min)')
```
\

###### <span style="color:#f75f28">*Commute frequency (max)*</span>
Margin of Error
```{r commuting frequency max : MOE setup, include=FALSE}
# User defined variables on each analysis:
# this is the weight for summing in your analysis
hh_wt_field<- 'hh_wt_combined'
# # this is a field to count the number of records
# person_count_field<-'person_dim_id'
# this is how you want to group the data in the first dimension,
# this is how you will get the n for your sub group
group_cat <- 'commute_freq_max'
# this is the second variable you want to summarize by
var <- 'vehicle_group'
# filter data missing weights
hh_no_na<-person_and_household %>% drop_na(all_of(hh_wt_field))
#filter data missing values
#before you filter out the data, you have to investigate if there are any NAs or missing values in your variables and why they are there.
sum(is.na(person_and_household$household_id)) #0
# now find the sample size of your subgroup
sample_size_group<- hh_no_na %>%
  group_by(commute_freq_max) %>%
  dplyr::summarize(sample_size = n())
sample_size_group
# get the margins of error for your groups
sample_size_MOE<- categorical_moe(sample_size_group)
# calculate totals and shares
cross_table<-cross_tab_categorical(hh_no_na,group_cat,var, hh_wt_field)
# merge the cross tab with the margin of error
cross_table_w_MOE<-merge(cross_table, sample_size_MOE, by=group_cat)
```

```{r commuting frequency max : vehicle Count MOE}
cross_table_w_MOE
```

```{r commuting frequency max vehicle plot}
hh_vehcount_commutefreqmax_all <- person_and_household %>%
  filter(!is.na(commute_freq_max)) %>%
  group_by(commute_freq_max,vehicle_group) %>%
  summarise(n=n(), HouseholdWeight = sum(hh_wt_combined))
# hh_vehcount_commutefreqmax_all 

ggplot(data=hh_vehcount_commutefreqmax_all, aes(x=commute_freq_max, y=n, fill= vehicle_group)) +
  geom_bar(stat="identity") +
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5)) +
  labs(x = "Commute Frequency (max)", 
       y = "Surveyed Households", 
       fill = "Vehicle Count",
       title = "Vehicle Count by Commute frequency (max)")
```

Reference group: 1 day a week
```{r commuting frequency max : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$commute_freq_max)
```

```{r commuting frequency max : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group,
                person_and_household$commute_freq_max,
                'Vehicle Count by Commute frequency (max)')
```
\
<span style="color:#20b2aa">Overall, the results from this analysis do not reveal a statistically significant association. There is a negative association between household vehicle count and household commute frequency (both max and min). Negative coefficients in the logistic regression model translate into odds ratios that are less than one, which means that the predicted probability is decreasing as the covariate increases. Odds ratios which are less than 1 imply a negative relationship between the outcome (vehicle count) and explanatory (commute frequency) variables. There are more statistically significant results from the household's least frequent commute frequency analysis.</span>
\

* <span style="color:#20b2aa"> **MINIMUM:** In reference to the households with an individual commuting 1 day a week (minimum), households commuting more frequently seem to own fewer vehicles. 
    * The odds of higher household vehicle count are 0.236 times lower for households where the least frequent commute is 6-7 days compared to households with at least one individual commuting of 1 day a week, given the other variables are held constant. This is statistically significant and reveals a negative association - less likely to own more vehicles.  
    * As the minimum commuting frequency increases, the odds ratios steadily decrease (although all less than 1) revealing an overall negative association. The odds of higher vehicle count for households with less frequent commutes (2 days a week and 3 days a week) are lower (0.6492 and 0.5794 times lower, respectively). Both of these values are statistically significant (p<0.1 and p<0.5, respectively). 
* <span style="color:#20b2aa"> **MAXIMUM:** In part because of small sample sizes, the only statistically significant finding is for households where the most frequent commute is 3 days a week, meaning that all members of the household commute 3 or fewer days a week. 
    * The negative coefficient and the odds ratio below 1 indicate a negative relationship. This is in reference to households with the most frequent commute of 1 day (very small sample size). In reference to the households with an individual commuting at most 1 day a week, households commuting at most 3 days a week are more likely to own fewer vehicles. The odds of higher household vehicle count are 0.455 times lower for households where the most frequent commute is 3 days a week than for households with a most frequent commute of 1 day a week, given the other variables are held constant. 
\

<span style="color:#20b2aa">These results seem to contradict expected trends.</span>
\
\

###### <span style="color:#B60078">*Simplified commute frequency*</span>
The original survey-provided commute frequencies (8) have been simplified into the following 3 categories:

* Less than once a week
* 3 or fewer days a week
* 4 or more days a week
\

The commuting frequency data is aggregated to the household level. The following tables reflect the lowest and highest commuting frequencies of the individuals within each of the surveyed households (6,319). 
\

**Lowest commuting frequencies (simplified)**
```{r commuting frequency aggregated min simp}
freq(person_and_household$commute_freq_simp_min)
```
\
**Highest commuting frequencies (simplified)**
```{r commuting frequency aggregated max simp}
freq(person_and_household$commute_freq_simp_max)
```
\

###### <span style="color:#f75f28">*Simp. commute frequency (min)*</span>
Margin of Error
```{r commuting frequency min simp : MOE setup, include=FALSE}
# User defined variables on each analysis:
# this is the weight for summing in your analysis
hh_wt_field<- 'hh_wt_combined'
# # this is a field to count the number of records
# person_count_field<-'person_dim_id'
# this is how you want to group the data in the first dimension,
# this is how you will get the n for your sub group
group_cat <- 'commute_freq_simp_min'
# this is the second variable you want to summarize by
var <- 'vehicle_group'
# filter data missing weights
hh_no_na<-person_and_household %>% drop_na(all_of(hh_wt_field))
#filter data missing values
#before you filter out the data, you have to investigate if there are any NAs or missing values in your variables and why they are there.
sum(is.na(person_and_household$household_id)) #0
# now find the sample size of your subgroup
sample_size_group<- hh_no_na %>%
  group_by(commute_freq_simp_min) %>%
  dplyr::summarize(sample_size = n())
sample_size_group
# get the margins of error for your groups
sample_size_MOE<- categorical_moe(sample_size_group)
# calculate totals and shares
cross_table<-cross_tab_categorical(hh_no_na,group_cat,var, hh_wt_field)
# merge the cross tab with the margin of error
cross_table_w_MOE<-merge(cross_table, sample_size_MOE, by=group_cat, sort=FALSE)
```

```{r commuting frequency min simp : vehicle ownership MOE}
cross_table_w_MOE
```

```{r commuting frequency min simp vehicle ownership plot}
hh_vehcount_commutefreqmin <- person_and_household %>%
  filter(!is.na(commute_freq_simp_min)) %>%
  group_by(commute_freq_simp_min, vehicle_group) %>%
  summarise(n=n(), HouseholdWeight = sum(hh_wt_combined))
# hh_vehcount_commutefreqmin 

ggplot(data=hh_vehcount_commutefreqmin, aes(x=commute_freq_simp_min, y=n, fill= vehicle_group)) +
  geom_bar(stat="identity") +
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5)) +
  labs(x = "Commute Frequency (min)", 
       y = "Surveyed Households", 
       fill = "Vehicle Count",
       title = "Vehicle Count by Simplified Commuting Frequency (min)")
```

Reference group: Less than once a week
```{r commuting frequency min simp : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$commute_freq_simp_min)
```

```{r commuting frequency min simp : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group,
                person_and_household$commute_freq_simp_min,
                'Vehicle Count by Simplified Commuting Frequency (min)')
```
\
\

###### <span style="color:#f75f28">*Simp. commute frequency (max)*</span>
Margin of Error
```{r commuting frequency max simp : MOE setup, include=FALSE}
# User defined variables on each analysis:
# this is the weight for summing in your analysis
hh_wt_field<- 'hh_wt_combined'
# # this is a field to count the number of records
# person_count_field<-'person_dim_id'
# this is how you want to group the data in the first dimension,
# this is how you will get the n for your sub group
group_cat <- 'commute_freq_simp_max'
# this is the second variable you want to summarize by
var <- 'vehicle_group'
# filter data missing weights
hh_no_na<-person_and_household %>% drop_na(all_of(hh_wt_field))
#filter data missing values
#before you filter out the data, you have to investigate if there are any NAs or missing values in your variables and why they are there.
sum(is.na(person_and_household$household_id)) #0
# now find the sample size of your subgroup
sample_size_group<- hh_no_na %>%
  group_by(commute_freq_simp_max) %>%
  dplyr::summarize(sample_size = n())
sample_size_group
# get the margins of error for your groups
sample_size_MOE<- categorical_moe(sample_size_group)
# calculate totals and shares
cross_table<-cross_tab_categorical(hh_no_na,group_cat,var, hh_wt_field)
# merge the cross tab with the margin of error
cross_table_w_MOE<-merge(cross_table, sample_size_MOE, by=group_cat, sort=FALSE)
```

```{r commuting frequency max simp : vehicle ownership MOE}
cross_table_w_MOE
```

```{r commuting frequency max simp vehicle ownership plot}
hh_vehcount_commutefreqmax <- person_and_household %>%
  filter(!is.na(commute_freq_simp_max)) %>%
  group_by(commute_freq_simp_max,vehicle_group) %>%
  summarise(n=n(), HouseholdWeight = sum(hh_wt_combined))
# hh_vehcount_commutefreqmax 

ggplot(data=hh_vehcount_commutefreqmax, aes(x=commute_freq_simp_max, y=n, fill= vehicle_group)) +
  geom_bar(stat="identity") +
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5)) +
  labs(x = "Commute Frequency (max)", 
       y = "Surveyed Households", 
       fill = "Vehicle Count",
       title = "Vehicle Count by Simplified Commute frequency (max)")
```

Reference group: Less than once a week
```{r commuting frequency max simp : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$commute_freq_simp_max)
```

```{r commuting frequency max simp : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group,
                person_and_household$commute_freq_simp_max,
                'Vehicle Count by Simplified Commute frequency (max)')
```
\
<span style="color:#20b2aa">Household commute frequency does not have a clear relationship with household vehicle count based on the simplification and aggregation techniques.</span>
\

* <span style="color:#20b2aa">In reference to the households with an individual commuting 3 or fewer days a week (**minimum**), both those commuting less than once a week (not statistically significant) and those working 4 or more times a week (statistically significant, p<0.01) have fewer household vehicles than households.
* <span style="color:#20b2aa">In reference to the households with an individual commuting 3 or fewer days a week (**maximum**),  those commuting less than once a week have fewer household vehicles (not statistically significant) than households with an individual commuting 3 or fewer days a week. Households commuting 4 or more times a week have more household vehicles (statistically significant, p<0.1).
\

<span style="color:#20b2aa">The lack of statistical power for the households with individuals commuting less than once a week is likely because of the small sample size (147/6,319 ~2% of total sample) and the large MOE.</span>
\
\

##### <span style="color:#486CAB">*Household Commute Trips*</span>
This variable measures the number of commute trips that occur within a household by the number of commute trips that would be anticipated for the number of workers within a household. This variable was calculated by dividing the sum of household commute trips per week by the number of workers within the household multiplied by 5 (sum of household commute trips/(numworkers*5)). This value assumes that most workers commute 5 days a week.  
\
Aggregated data at a household level (6,319 survey respondents). 
```{r commuting trips}
summary(person_and_household$hh_commutetrips)
```

```{r commuting trips plot}
# plot histogram
ggplot(person_and_household, aes(hh_commutetrips)) + 
  geom_histogram(bins=30)+
  labs(x = "Commute Trips by Household Workers", 
       y = "Surveyed Respondents")
```

```{r commuting trips : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$hh_commutetrips)
```

```{r commuting trips : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group, 
                 person_and_household$hh_commutetrips,
                "Vehicle Count by Trips:Worker Ratio")
```
\
<span style="color:#20b2aa">The number of commute trips by workers within the household is positively associated with higher household vehicle count This relationship is statistically significant.</span>
\
\

#### <span style="color:#009D6A">*12. Transit accessibility*</span>
Transit accessibility is measured at a census block geographic scale. These values are calculated using the transit score methodology (https://www.walkscore.com/transit-score-methodology.shtml) and are scaled by determining the log of the highest score (downtown Seattle) and the minimum score above 0. Higher values indicate greater transit accessibility.
\
Because the scores are by census block and survey respondents provided their home locations, this variable measures transit accessibility based on housing location (instead of work location). Work location is not considered in this analysis because it is at a person-level, instead of a household-level. **Future work could take the average of the transit scores associated with household members' work locations.**   
\
*For more information about the generation of the raw or scaled block group transit scores, please contact Stefan Coe.* 

```{r transit acc : stats}
# freq(person_and_household$scaled_score)
summary(person_and_household$scaled_score)
```

```{r transit acc plot}
# plot histogram
ggplot(person_and_household, aes(scaled_score)) + 
  geom_histogram(bins=30)+
  labs(x = "Transit Accessibility", 
       y = "Surveyed Respondents")
```

```{r transit acc : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$scaled_score)
```

```{r transit acc : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group, 
                 person_and_household$scaled_score,
                "Vehicle Count by Household Transit Accessibility")
```
\
<span style="color:#20b2aa">Transit accessibility is negatively associated with household vehicle count, with households living in block groups with higher access to transit owning fewer household vehicles. This relationship is statistically significant.</span>
\
\

#### <span style="color:#009D6A">*13. Proximity to jobs and services*</span>
Proximity to services is based on a displacement risk index created by PSRC. Although there are a number of variables that were explored to create the index, this analysis will include the following:

* jobs accessible by automobile (30min)
* jobs accessible by transit (45m)
* distance to a supermarket (mi)
* distance to a school (mi)

*other variables not included in this analysis: distance to pharmacies, restaurants, parks*
\
\

##### <span style="color:#486CAB">*Jobs accessible by automobile (30min)*</span>  
This value is calculated by 
```{r job accessibility auto : stats}
summary(person_and_household$ln_jobs_auto_30)
```

```{r job accessibility auto plot}
# plot histogram
ggplot(person_and_household, aes(ln_jobs_auto_30)) + 
  geom_histogram(bins=10)+
  labs(x = "Job Accessibility (auto, 30min)", 
       y = "Surveyed Respondents")
```

```{r job accessibility auto : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$ln_jobs_auto_30)
```

```{r job accessibility auto : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group, 
                 person_and_household$ln_jobs_auto_30,
                "Vehicle Count by Job Accessibility (auto)")
```
\
\

##### <span style="color:#486CAB">*Jobs accessible by transit (45min)*</span>  
This value is calculated by 
```{r job accessibility transit : stats}
summary(person_and_household$ln_jobs_transit_45)
```

```{r job accessibility transit plot}
# plot histogram
ggplot(person_and_household, aes(ln_jobs_transit_45)) + 
  geom_histogram(bins=10)+
  labs(x = "Job Accessibility (transit, 45min)", 
       y = "Surveyed Respondents")
```

```{r job accessibility transit : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$ln_jobs_transit_45)
```

```{r job accessibility transit : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group, 
                 person_and_household$ln_jobs_transit_45,
                "Vehicle Count by Job Accessibility (transit)")
```
\
\

##### <span style="color:#486CAB">*Distance to a supermarket*</span>  
This value is calculated by 
```{r supermarket distance : stats}
summary(person_and_household$dist_super)
```

```{r supermarket distance plot}
# plot histogram
ggplot(person_and_household, aes(dist_super)) + 
  geom_histogram(bins=30)+
  labs(x = "Supermarket Distance (mi)", 
       y = "Surveyed Respondents")
```

```{r supermarket distance : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$dist_super)
```

```{r supermarket distance : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group, 
                 person_and_household$dist_super,
                "Vehicle Count by Distance to a Supermarket")
```
\
\

##### <span style="color:#486CAB">*Distance to a school*</span>  
This value is calculated by 
```{r school distance : stats}
summary(person_and_household$dist_school)
```

```{r school distance plot}
# plot histogram
ggplot(person_and_household, aes(dist_school)) + 
  geom_histogram(bins=30)+
  labs(x = "School Distance (mi)", 
       y = "Surveyed Respondents")
```

```{r school distance : bivariate analysis}
bivariate_Pvalue(person_and_household$vehicle_group, 
                 person_and_household$dist_school)
```

```{r school distance : stargazer table, results='asis'}
stargazer_table(person_and_household$vehicle_group, 
                 person_and_household$dist_school,
                "Vehicle Count by Distance to a school")
```
\

<span style="color:#20b2aa">Overall, the relationship between proximity to jobs and services and household vehicle count is statistically significant.
\


* **job accessibility **
\
    + *by automobile (30min)*: Higher jobs accessibility by automobile is associated with lower vehicle count
    + *by transit (45m)*: Higher job accessibility by transit is associated with lower vehicle count, weaker relationship when compared to job accessibility by auto 
\

* **distance to services (mi)**
\
    + *supermarket*: Farther distance between house and supermarket is associated with higher vehicle count
    + *school*: Farther distance between house and school is associated with higher vehicle count, weaker relationship when compared to supermarket distance
\
\

### b. Overview: univariate analysis results  
The table below shows which explanatory variables were statistically significant when analyzed against household vehicle count. Significance: &ast;p<0.1; &ast;&ast;&ast;p<0.05; &ast;&ast;&ast;p<0.01

```{r univariate analysis results, results='asis'}
c1 <- as.data.frame(c(
  "1. Income",
  "2. Age/Lifecycle",
  "3. Household size",
  "4. Number of household licenses",
  "5. Number of workers",
  "6. Number of jobs",
  "7. Educational Attainment",
  "8. Race",
  "9. Housing",
  "10. Housing location",
  "11. Commute patterns",
  "12. Transit accessibility",
  "13. Proximity to jobs and services"))
colnames(c1)[1] <- "Explanatory variables"
c2 <- as.data.frame(c(
  "***",
  "***",
  "***",
  "***",
  "***",
  "***",
  "** and ***",
  "** and ***",
  "** and ***",
  "***",
  "<span>&#42; and ***</span>",
  "***",
  "***"))
colnames(c2)[1] <- "Significance"
c3 <- as.data.frame(c(
  "higher income",
  "households with children and older individuals",
  "larger households",
  "higher number of household licenses",
  "higher number of workers",
  "higher jobs:workers ratio",
  "*depends on aggregation technique (min or max)*",
  "white only households",
  "households that own and live in single-family detached homes",
  "households located in RGCs",
  "farther commute distances, longer commute times, households with more commute trips/worker",
  "lower transit accessibility",
  "lower job accessibility, reduced proximity to services"))
colnames(c3)[1] <- "Trend (higher household vehicle count)"

corresponding <- cbind(c1,c2, c3)

# print table using kable()
kable(corresponding, format = "html",escape = FALSE, align = c('l','l','l')) %>% kable_styling("bordered",full_width = F, position = "left") #%>% column_spec(2, color = "red")#%>% column_spec(2, bold = T)
```
\

## 4. Correlation matrix with numerical variables
The dependent variable is household vehicle count (`vehicle_group`: 0, 1, 2, 3+).   
The explanatory variables can be categorized as **categorical** and *numeric*. The reference group is provided for the categorical variables. 
\
```{r reference variables, eval=FALSE, include=FALSE}
table(person_and_household$hhincomeb_reordered) # Under $25k is reference
table(person_and_household$hh_lifecycle) # Under age 35
table(person_and_household$hhsize_simp_num) # numeric, not categorical
table(person_and_household$driver_simp) # numeric, not categorical
table(person_and_household$numworkers_simp) # numeric, not categorical 
table(person_and_household$jobs_numworkers) # numeric, not categorical
table(person_and_household$hh_edu_max_simp) # Bachelor degree for both min and max
table(person_and_household$hh_race_2) # White Only for both race categorizations
table(person_and_household$rent_own_simp) # Own/paying mortgage
table(person_and_household$restype_simp) # Apartment/condo
table(person_and_household$RGC_binary) # Not RGC 
table(person_and_household$commute_freq_simp_min) # Less than once a week for both min and max
table(person_and_household$scaled_score) # numeric, not categorical
table(person_and_household$ln_jobs_auto_30) # numeric, not categorical
```
**1. Income : Under $25k is reference**  
**2. Age/Lifecycle : Under age 35**  
*3. Household size*  
*4. Number of household licenses*  
*5. Number of workers*  
*6. Number of jobs*  
**7. Educational Attainment : Bachelor degree**  
**8. Race : White Only**  
**9. Housing : (1) Own/paying mortgage; (2) Apartment/condo**  
**10. Housing location : Not RGC**  
**11. Commute patterns : Less than once a week (frequency)**  
*12. Transit accessibility*  
*13. Proximity to jobs and services* 
\
\

### Correlation background
The correlation matrix table will illustrate relationships or associations between the variables. The correlation coefficients measure the strength of the relationship and the direction of the correlation (positive or negative). This analysis represents a subset of the variables - numerical, not categorical.
```{r correlation matrix : setup}
# select data
correl_data <- person_and_household %>%
  dplyr::select(vehicle_group,
                hhsize_simp_num,
                driver_simp,
                numworkers_simp,
                jobs_numworkers,
                hh_com_auto_time_avg, hh_com_auto_time_sum, hh_commutetrips,
                scaled_score,
                ln_jobs_auto_30, ln_jobs_transit_45, dist_super, dist_school)
```
\
The correlation coefficients are based on a Pearson correlation test.
*Pearson correlation measures the strength of a linear relationship between normally distributed variables.* The Spearman correlation coefficients (rank-based) could be an alternative way to analyze the data. 
\
\
The degree of correlation can be interpreted differently depending on area of study. The following interpretations are based on the absolute value of the coefficients.

* Based on psychological research, Cohen's (1988) conventions indicate that effect sizes, or correlation coefficients, can be interpreted as: **0.10 (small), 0.30 (moderate), 0.50 (large)**
* Ratner (2009) introduces an alternative set of "accepted guidelines for interpreting the correlation coefficient": **0-0.30 (weak), 0.30-0.70 (moderate), 0.70-1.0 (strong)**  

For simplicity, the correlation coefficients will be interepreted based on Cohen's effect size benchmarks. 


<font size="1">Sources:  
* Cohen, Jacob (1988). Statistical Power Analysis for the Behavioral Sciences, p. 115.  
* Ratner, Bruce (2009). "The correlation coefficient: Its values range between +1/-1, or do they?" Journal of Targeting Measurement and Analysis for Marketing.</font>

### Correlation coefficients
```{r correlation matrix : coefficients}
# create matrix
cor_matrix <- round(cor(x = as.matrix(correl_data),
                      method = "pearson", use = "pairwise.complete.obs"),3)
# cor_matrix

# Hide upper triangle
upper<-cor_matrix
upper[upper.tri(cor_matrix)]<-""
upper<-as.data.frame(upper, nrow=15, ncol=15)
print.data.frame(upper)
```
\
\

### Significance levels (p-values)
```{r correlation matrix : p-values}
# p-values for matrix (requires "Hmisc" package) - generates one table of correlation coefficients (the correlation matrix) and another table of the p-values
cor_matrix_pvalues <-  rcorr(as.matrix(correl_data))
# extract p-values
round(cor_matrix_pvalues$P,3)
```
\
\
```{r correlation plot}
# corrplot.mixed(cor_matrix)
corrplot::corrplot(cor_matrix, type = "lower", tl.col = "black", tl.srt = 45)

# # include p-values
# res1 <- cor.mtest(correl_data, conf.level = .95)
# 
# corrplot(cor_matrix, type = "lower", p.mat = res1$p, insig = "label_sig",
#          sig.level = c(.001, .01, .05), pch.cex = .9, pch.col = "white")
# corrplot(cor_matrix,type = "lower", p.mat = res1$p, insig = "label_sig", pch.col = "white",
#          pch = "p<.05", pch.cex = .5)
```
\
Based on the correlation matrix, household vehicle count is most correlated with the number of licensed household members (*0.569 = large correlation*), household size (*0.491 = moderate correlation*), and transit accessibility (*-0.477 = moderate correlation*).
\
\

## 5. Identifying important variables
### Model with all variables
The ordered logit model reports the effects of X on Y when “controlling” for the other independent variables. This model tests main effects - assessing the relationship between each independent variable and the dependent variable (household vehicle count).
```{r full model : analysis}
# documentation about function: https://www.rdocumentation.org/packages/MASS/versions/7.3-52/topics/polr
ordered_logit_all <-polr(as.factor(vehicle_group) ~
                       hhincomeb_reordered +
                       hh_lifecycle + 
                       hhsize_simp_num +
                       driver_simp +
                       numworkers_simp +
                       jobs_numworkers +
                       hh_edu_min_simp + hh_edu_max_simp +
                       hh_race_2 +
                       rent_own_simp + restype_simp +
                       RGC_binary +
                       hh_com_auto_time_avg + hh_com_auto_time_sum + commute_freq_simp_min + commute_freq_simp_max + hh_commutetrips +
                       scaled_score +
                       ln_jobs_auto_30 + ln_jobs_transit_45 + dist_super + dist_school,
                       data=person_and_household, Hess = T)

# adding coefficients and p-values store table
ctable <- round(coef(summary(ordered_logit_all)),2)
# calculate and store p values
p <- round(pnorm(abs(ctable[,"t value"]), lower.tail = F)*2,3)
# odds ratio
oddsratio <- round(exp(coef(ordered_logit_all)),2)
# combined table
ctable <-cbind(ctable, "p value"=p, "odds ratio"=oddsratio)
ctable
```

```{r McFadden R2 model}
# Resource: http://finzi.psych.upenn.edu/R/library/DescTools/html/PseudoR2.html

PseudoR2(ordered_logit_all, "all")
```
\
<span style="color:#20b2aa">This model indicates that of the variables included, higher household vehicle count is most associated with: **household licenses, household income, commute frequency (?), household lifecycle, and residential type**. 
\
\
This interpretation is based on the odds ratios. For example, for the households in the `$100,000 or more` income category, the odds of owning more vehicles (vs. owning 0 vehicles) is 3.276 times that of households in the reference income group (`Under $25,000`).</span>
\
```{r full model: stargazer table, results='asis', include=FALSE}
stargazer::stargazer(ordered_logit_all,
                     type = "html",
                     title = "Ordered Logit for all variables",
                     notes.append = FALSE,
                     notes =  c("<sup>&sstarf;</sup>p<0.1;<sup>&sstarf;&sstarf;</sup>p<0.05;<sup>&sstarf;&sstarf;&sstarf;</sup>p<0.01"))
```
\

### Numerical variables
Although the majority of the individual correlations between vehicle count and the explanatory variables are significant, incorporating interaction effects into the model will contribute to more fully understanding the relationship. Therefore, the next step requires determining which variable interactions should be added to the model.
\

Overall, the dependent, or explanatory, variables can be organized into 3 categories: 
```{r explanatory variables table, results='asis'}
c1 <- as.data.frame(c(
  "household income",
  "household lifecycle",
  "household size",
  "number of household licenses",
  "number of workers",
  "number of jobs",
  "educational attainment",
  "race"))
colnames(c1)[1] <- "Socioeconomic (SES) variables"
c2 <- as.data.frame(c(
  "housing tenure",
  "housing type",
  "housing location",
  "commute time - auto",
  "commute frequency",
  "household commute trips",
  "",
  ""))
colnames(c2)[1] <- "Home and work related variables"
c3 <- as.data.frame(c(
  "transit accessibility",
  "jobs accesible by 30m - auto",
  "jobs accessible by 45m - transit",
  "distance to supermarkets",
  "distance to schools",
  "",
  "",
  ""))
colnames(c3)[1] <- "Accessibility variables (based on home location)"

corresponding <- cbind(c1,c2, c3)

# print table using kable()
kable(corresponding, format = "html",escape = FALSE, align = c('l','l','l')) %>% kable_styling("bordered",full_width = F, position = "left")
```

#### <span style="color:#009D6A">Based on correlation coefficients</span>
Identifying variables that are highly correlated is important to reduce unreliable results from multicollinearity.

##### <span style="color:#486CAB">*SES characteristics*</span>
Of the SES-related variables, `number of household licenses` is most highly correlated with vehicle count (*0.57 = large correlation*). As a result, **`number of household licenses`** has the best explanatory power and will be included in the model as the SES-variable.
\
\
When compared to the other SES-related variables, the `number of household licenses` is most correlated with `household size` (*0.81 = large correlation*) and the `number of household workers` (*0.48 = moderate correlation*), so these will not be included in the same model but can be used as alternatives. 
\
\
`Jobs per worker` and `number of workers` are also highly correlated (*0.74 = large correlation*) because of the way that the former was calculated. Out of these two variables, vehicle count is more highly correlated with the `number of workers` *(0.29 = small correlation)* than `jobs per worker` *(0.14 = small correlation)*. Both `number of workers` and `jobs per worker` are correlated with `number of household licenses` (*0.48 = moderate correlation* and *0.26 = small correlation*, respectively). Both are correlated with number of `household size` (*0.48 = moderate correlation* and *0.25 = small correlation*, respectively). Because of these correlations, neither will be included in the model. 
\
\

##### <span style="color:#486CAB">*Home/work characteristics*</span>
Of the home and work-related variables, `total auto commuting time` is most highly correlated with vehicle count (*0.147 = small correlation*), closely followed by `average auto commuting time` (*0.145 = small correlation*).
\
\
Based on these results, **`total commuting time`** has the best explanatory power and will be included in the model as the home/work variable. 
\
\
An alternative could be `number of household commute trips`, as is most correlated with `total auto commuting time` (*0.21 = small correlation*), after average auto commuting time. If used as an alternative, there are correlations between the `number of household commute trips` and the SES variables: `number of household licenses` (*0.27 = small correlation*) and `jobs per worker` (*0.59 = large correlation*).  
\
\

##### <span style="color:#486CAB">*Accessibility characteristics*</span>
Of the accessibility-related variables, `transit score` is most highly correlated with vehicle count (*-0.477 = moderate correlation*). When compared to the other accessibility-related variables, `transit score` is highly correlated with `jobs accessible by transit within 45 minutes` (*0.786 = large correlation*), `jobs accessible by auto within 30 minutes` (*0.763 = large correlation*), and `distance to supermarkets` (*-0.699 = large correlation*).
\
\
Based on these results, **`transit score`** has the best explanatory power and will be included in the model as the accessibility variable. 
\
\
Alternatives could be `jobs accessible by auto within 30 minutes` (*-0.39 = moderate correlation*), or  `jobs accessible by transit within 45 minutes` (*-0.38 = moderate correlation*), which are the second and third most correlated accessibility variables when considering vehicle count, respectively.
\
\

### Categorical Variables
Because these variables are not included in the correlation matrix, finding categorical variables with explanatory power requires more interpretation of the values that reflect significance (t- and p-values). 
\
\
**Explanatory power**

* Household income
* Household lifecycle
* Housing tenure (Rent / Own)
* Housing location (RGC / non-RGC)
\

**Slight explanatory power**

* Household residential type: Significant when comparing between single-family and apartment/condo
* Commute frequency: Minimum, not maximum aggregation
\

**Little explanatory power**

* Household education: Minimum aggregation technique appears to have more explanatory power than maximum aggregation
* Race: Although the univariate analysis between vehicle count and household race (`hh_race_2`: comparing white only and POC households) does indicate a significant relationship (p<0.01), it is not significant when included in the ordered logit model.   
\
\

## 6. Adjusted Models
The ordered logit model reports the effects of X on Y when “controlling” for the other independent variables. This model tests main effects - assessing the relationship between each independent variable and the dependent variable (household vehicle count).

The following models will include different combinations of the numerical and categorical variables that seem to have the most explanatory power.

### First try: *Model 1*
This smaller model includes the important numerical variables that were identified above and the categorical variables with explanatory power.
```{r adj full model 1 : analysis}
# documentation about function: https://www.rdocumentation.org/packages/MASS/versions/7.3-52/topics/polr
ordered_logit_1 <-polr(as.factor(vehicle_group) ~
                       hhincomeb_reordered +
                       hh_lifecycle + 
                       driver_simp +
                       numworkers_simp +
                       rent_own_simp +
                       RGC_binary +
                       hh_com_auto_time_sum +
                       scaled_score,
                     data=person_and_household, 
                     Hess = T)

# adding coefficients and p-values store table
ctable <- round(coef(summary(ordered_logit_1)),2)
# calculate and store p values
p <- round(pnorm(abs(ctable[,"t value"]), lower.tail = F)*2,3)
# odds ratio
oddsratio <- round(exp(coef(ordered_logit_1)),2)
# combined table
ctable <-cbind(ctable, "p value"=p, "odds ratio"=oddsratio)
ctable
```

```{r McFadden R2 model1}
PseudoR2(ordered_logit_1, "all")
```

### Second try: *Model 2*
This slightly expanded model includes the important numerical variables that were identified above and the categorical variables with explanatory power *and slight explanatory power* are included.
```{r adj full model 2 : analysis}
# documentation about function: https://www.rdocumentation.org/packages/MASS/versions/7.3-52/topics/polr
ordered_logit_2 <-polr(as.factor(vehicle_group) ~
                       hhincomeb_reordered +
                       hh_lifecycle + 
                       driver_simp +
                       numworkers_simp +
                       rent_own_simp + restype_simp +
                       RGC_binary +
                       hh_com_auto_time_sum +
                       commute_freq_simp_min +
                       scaled_score,
                     data=person_and_household, 
                     Hess = T)

# adding coefficients and p-values store table
ctable <- round(coef(summary(ordered_logit_2)),2)
# calculate and store p values
p <- round(pnorm(abs(ctable[,"t value"]), lower.tail = F)*2,3)
# odds ratio
oddsratio <- round(exp(coef(ordered_logit_2)),2)
# combined table
ctable <-cbind(ctable, "p value"=p, "odds ratio"=oddsratio)
ctable
```

```{r McFadden R2 model2}
PseudoR2(ordered_logit_2, "all")
```
\

### Comparing Models
"Although there's no commonly accepted agreement on how to assess the fit of a logistic regression, there are some approaches. The goodness of fit of the logistic regression model can be expressed by some variants of pseudo R squared statistics, most of which being based on the deviance of the model."
\

* Source: http://finzi.psych.upenn.edu/R/library/DescTools/html/PseudoR2.html 
\
\

#### <span style="color:#009D6A">Pseudo R Statistics</span> 
McFadden's pseudo R2 provides one way to determine the fit of a logistic regression model, based on the deviance of the model.  In a 1977 article, McFadden writes, "Those unfamiliar with the $\rho^{2}$ index should be forewarned that those of the $R^{2}$ index and should not be judged by the standards for a 'good fit' in ordinary regression analysis. For example, values of .2 to .4 for $\rho^{2}$ represent an excellent fit."
\

* Source: http://cowles.yale.edu/sites/default/files/files/pub/d04/d0474.pdf (p. 36)
\

"Veall and Zimmermann concluded that from a set of six widely used measures the measure suggested by McKelvey and Zavoina had the closest correspondance to ordinary least square R2. The Aldrich-Nelson pseudo-R2 with the Veall-Zimmermann correction is the best approximation of the McKelvey-Zavoina pseudo-R2. Efron, Aldrich-Nelson, McFadden and Nagelkerke approaches severely underestimate the "true R2"."
\
\

#### <span style="color:#009D6A">AIC and BIC</span> 
Akaike information criterion (AIC) and Bayesian information criterion (BIC) are values that can be compared across competing models to determine goodness-of-fit. 
\

**AIC**  
"The AIC in isolation is meaningless. Rather, this value is calculated for every candidate model and the 'best' model is the candidate model with the smallest AIC...The more parameters, the greater the amount added to the first component, increasing the value for the AIC and penalizing the model. Hence, there is a trade-off: the better fit, created by making a model more complex by requiring more parameters, must be considered in light of the penalty imposed by adding more parameters" (p. 400).
\

**BIC**  
"The difference between the BIC and AIC is the greater penalty imposed for the number of parameters by the former than the latter...in the case of multivariate regression analysis, Yang explains why AIC is better than BIC in model selection" (p. 403).
\

Source: https://onlinelibrary.wiley.com/doi/pdf/10.1002/9781118856406.app5
\
\

#### <span style="color:#009D6A">Comparison Results</span> 
Based on the McFadden and AIC/BIC values, the full model seems to have the best fit. 
\
Model 1 is a slightly better fit than Model 2 according to McFadden, but is a worse fit according to the AIC/BIC values.
\
\
\

#### <span style="color:#009D6A">Example</span> 
 The influence of residential type changes in model 2, when compared to the full model with all variables. The trend remains similar for households living in **single-family housing** - remaining significant, although becoming slightly more explanatory.
```{r res type comparison table, results='asis'}
c1 <- as.data.frame(c(
  "Coefficient",
  "Std. error",
  "t-value",
  "p-value",
  "Odds ratio",
  "McFadden",
  "AIC",
  "BIC"))
colnames(c1)[1] <- "Values"
c2 <- as.data.frame(c(
  "0.75",
  "0.16",
  "4.73",
  "0.00",
  "2.12",
  "0.32",
  "3,272.44",
  "3,505.55"))
colnames(c2)[1] <- "Full Model"
c3 <- as.data.frame(c(
  "0.90",
  "0.10",
  "8.97",
  "0.00",
  "2.45",
  "0.29",
  "7,822.34",
  "7,976.87"))
colnames(c3)[1] <- "Model 2"

corresponding <- cbind(c1,c2, c3)

# print table using kable()
kable(corresponding, format = "html",escape = FALSE, align = c('l','l','l')) %>% 
  kable_styling("bordered",full_width = F, position = "left") %>%
  column_spec(1, italic = T)
```
\
\

## 7. Summary / Future Research

### Main findings
This section summarizes the results presented in Section 5: Identifying important variables. 
\

#### <span style="color:#009D6A">*Dependent variable*</span>  
Household vehicle count, in response to the question: "How many motor vehicles (in working order) are there in your household?" Households are categorized into groups with 0, 1, 2, or 3+ vehicles. 
\
\

The following results are based on Model 1 (above)

#### <span style="color:#009D6A">*Most significant explanatory factors*</span>
These variables are ordered based on impact - the highest odds ratio. All of them are significant (high t-values and low p-values). The relationship between the dependent variable (household vehicle count) and the explanatory variable is summarized in sub-bullet points. 

* **Number of household licenses** [household members with license or permit]
    + <span style="color:#20b2aa">Positive</span>: more household licenses &rightarrow; more vehicles
* **Income** [5 broad income categories]
    + <span style="color:#20b2aa">Positive</span>: more income &rightarrow; more vehicles
* **Household lifecycle** [age of household members, presence of children]
    + <span style="color:#20b2aa">Positive</span>: older household members &rightarrow; more vehicles
    + Households with children &rightarrow; fewer vehicles
* **Number of workers** [household members with 1+ jobs]
    + <span style="color:#20b2aa">Positive</span>: more household workers &rightarrow; more vehicles
* **Total commuting time** [minutes by automobile]
    + <span style="color:#20b2aa">Positive</span>: higher commute times by automobile \rightarrow more vehicles
* **Transit accessibility** [transit score, scaled to region]
    + <span style="color:#20b2aa">Negative</span>: better transit accessibility/higher transit scores &rightarrow; fewer vehicles
* **Housing in/out of RGC** [housing location within a Regional Growth Center]
    + Living in the RGC (vs. outside RGC) &rightarrow; fewer household vehicles
    + *Note: variable likely related to transit accessibility*
* **Housing tenure**
    + Households renting their homes (vs. owning) &rightarrow; fewer households vehicles
    + *Note: "other" housing category is likely affecting the model statistics*
\

#### <span style="color:#009D6A">*For consideration*</span>
From model 2, these variables are statistically significant. 

* **Residential type**: single-family (in reference to apartment/condo) is significant and has relatively strong impact, other residential types are not significant
* **Commute frequency**: min vs. max aggregation techniques reveal differing significance levels and impact
\

#### <span style="color:#009D6A">*Of interest*</span>

* **Race**: Although the univariate analysis between vehicle count and household race (hh_race_2: comparing white only and POC households) does indicate a significant relationship (p<0.01), it is not significant when included in the full ordered logit model. 
* **Education**: Household-level aggregation techniques (min, max) result in contradicting trends (univariate analysis). Education as a variable is not significant in the full ordered logit model.
\
\ 
 
### Revised Models with Race
Model 1 includes the variables that had the largest impact on household vehicle count in the full model. The following model will incorporate race to determine possible effects.
\

#### *Model 1a (with race)*
```{r adj full model 1 with race : analysis}
# documentation about function: https://www.rdocumentation.org/packages/MASS/versions/7.3-52/topics/polr
ordered_logit_1_race <-polr(as.factor(vehicle_group) ~
                              hhincomeb_reordered +
                              hh_lifecycle + 
                              driver_simp +
                              numworkers_simp +
                              hh_race_2 +
                              rent_own_simp +
                              RGC_binary +
                              hh_com_auto_time_sum +
                              scaled_score,
                            data=person_and_household,
                            Hess = T)

# adding coefficients and p-values store table
ctable <- round(coef(summary(ordered_logit_1_race)),2)
# calculate and store p values
p <- round(pnorm(abs(ctable[,"t value"]), lower.tail = F)*2,3)
# odds ratio
oddsratio <- round(exp(coef(ordered_logit_1_race)),2)
# combined table
ctable <-cbind(ctable, "p value"=p, "odds ratio"=oddsratio)
ctable
```

```{r McFadden R2 model1 with race}
PseudoR2(ordered_logit_1_race, "all")
```
Race in this model (Model 1a) is significant. Households of color (in reference to White only households) are more likely to own fewer vehicles. The strength of this association may be impacted by the "Missing/Other" race category. 
\
Based on the McFadden values, this model is slightly worse than the full model, but better than Model 1 and Model 2. 
\
This model is a slightly better fit than Model 1 or Model 2 according to McFadden. Based on AIC values it is slightly better than Model 1 and worse than Model 2. Based on BIC values it is slightly worse than Model 1 and worse than Model 2.   
\

#### *Model 2a (with race)*
Model 2 includes the important numerical variables that were identified above and the categorical variables with explanatory power *and slight explanatory power* are included.
```{r adj full model 2 with race : analysis}
# documentation about function: https://www.rdocumentation.org/packages/MASS/versions/7.3-52/topics/polr
ordered_logit_2_race <-polr(as.factor(vehicle_group) ~
                              hhincomeb_reordered +
                              hh_lifecycle +
                              driver_simp +
                              numworkers_simp +
                              hh_race_2 +
                              rent_own_simp + restype_simp +
                              RGC_binary +
                              hh_com_auto_time_sum +
                              commute_freq_simp_min +
                              scaled_score,
                            data=person_and_household,
                            Hess = T)

# adding coefficients and p-values store table
ctable <- round(coef(summary(ordered_logit_2_race)),2)
# calculate and store p values
p <- round(pnorm(abs(ctable[,"t value"]), lower.tail = F)*2,3)
# odds ratio
oddsratio <- round(exp(coef(ordered_logit_2_race)),2)
# combined table
ctable <-cbind(ctable, "p value"=p, "odds ratio"=oddsratio)
ctable
```

```{r McFadden R2 model2 with race}
PseudoR2(ordered_logit_2_race, "all")
```
Race in this model (Model 2a) is significant - less significant than in Model 1a, but the odds ratio is higher. Households of color (in reference to White only households) are more likely to own fewer vehicles. The strength of this association may be impacted by the "Missing/Other" race category. 
\
Based on the McFadden values, this model is slightly worse than the full model and Model 1a, but better than Model 1 and Model 2. 
\
This model is a slightly worse fit than Model 1 and slightly better than Model 2 according to McFadden. Based on AIC values it is slightly better than Models 1, 1a, and 2. Based on BIC values it is slightly worse than Model 2, and worse than Models 1 and 1a.   
\
\

### Variable interactions
Because some of the independent variables may interact with each other, as shown through the correlation matrix, considering interaction effects can add complexity because they incorporate an additional dimension - a third variable influencing the relationship between the independent and dependent variable.
\
\

#### <span style="color:#009D6A">Some significance</span> 

##### <span style="color:#486CAB">*Race and Income*</span>
```{r test important interactions model 2: analysis}
# documentation about function: https://www.rdocumentation.org/packages/MASS/versions/7.3-52/topics/polr
ordered_logit <-polr(as.factor(vehicle_group) ~
                       hhincomeb_reordered*hh_race_2 +
                       hh_lifecycle +
                       driver_simp +
                       jobs_numworkers +
                       hh_edu_min_simp + hh_edu_max_simp +
                       rent_own_simp + restype_simp +
                       RGC_binary +
                       hh_com_auto_time_sum +
                       scaled_score,
                       data=person_and_household, Hess = T)

# adding coefficients and p-values store table
ctable <- round(coef(summary(ordered_logit)),2)
# calculate and store p values
p <- round(pnorm(abs(ctable[,"t value"]), lower.tail = F)*2,3)
# odds ratio
oddsratio <- round(exp(coef(ordered_logit)),2)
# combined table
ctable <-cbind(ctable, "p value"=p, "odds ratio"=oddsratio)
ctable
```
\
<span style="color:#20b2aa">This model indicates that the interaction between race and income is not significant, but the interaction between household income of $25-50k and households with POC (non-white only households) are closest to being significant at p=0.077.</span>
\
\

##### <span style="color:#486CAB">*Race and Licenses*</span>
```{r test important interactions model 5: analysis}
# documentation about function: https://www.rdocumentation.org/packages/MASS/versions/7.3-52/topics/polr
ordered_logit <-polr(as.factor(vehicle_group) ~
                       hhincomeb_reordered +
                       hh_lifecycle +
                       hh_race_2*driver_simp +
                       jobs_numworkers +
                       hh_edu_min_simp + hh_edu_max_simp +
                       rent_own_simp +restype_simp +
                       RGC_binary +
                       hh_com_auto_time_sum +
                       scaled_score,
                       data=person_and_household, Hess = T)

# adding coefficients and p-values store table
ctable <- round(coef(summary(ordered_logit)),2)
# calculate and store p values
p <- round(pnorm(abs(ctable[,"t value"]), lower.tail = F)*2,3)
# odds ratio
oddsratio <- round(exp(coef(ordered_logit)),2)
# combined table
ctable <-cbind(ctable, "p value"=p, "odds ratio"=oddsratio)
ctable
```
\
<span style="color:#20b2aa">This model indicates that the interaction between race and the number of household licenses is significant (p<0.01).</span>
\
\

##### <span style="color:#486CAB">*Race and Jobs per workers*</span>
```{r test important interactions model 6: analysis}
# documentation about function: https://www.rdocumentation.org/packages/MASS/versions/7.3-52/topics/polr
ordered_logit <-polr(as.factor(vehicle_group) ~
                       hhincomeb_reordered +
                       hh_lifecycle +
                       hh_race_2*jobs_numworkers +
                       driver_simp +
                       hh_edu_min_simp + hh_edu_max_simp +
                       rent_own_simp +restype_simp +
                       RGC_binary +
                       hh_com_auto_time_sum +
                       scaled_score,
                       data=person_and_household, Hess = T)

# adding coefficients and p-values store table
ctable <- round(coef(summary(ordered_logit)),2)
# calculate and store p values
p <- round(pnorm(abs(ctable[,"t value"]), lower.tail = F)*2,3)
# odds ratio
oddsratio <- round(exp(coef(ordered_logit)),2)
# combined table
ctable <-cbind(ctable, "p value"=p, "odds ratio"=oddsratio)
ctable
```
\
<span style="color:#20b2aa">This model indicates that the interaction between race and the number of jobs per worker is close to being significant at p=0.056.</span>
\
\

##### <span style="color:#486CAB">*Race and Education (max)*</span>
```{r test important interactions model 7: analysis}
# documentation about function: https://www.rdocumentation.org/packages/MASS/versions/7.3-52/topics/polr
ordered_logit <-polr(as.factor(vehicle_group) ~
                       hhincomeb_reordered +
                       hh_lifecycle +
                       hh_race_2*hh_edu_max_simp +
                       jobs_numworkers +
                       driver_simp +
                       hh_edu_min_simp +
                       rent_own_simp +restype_simp +
                       RGC_binary +
                       hh_com_auto_time_sum +
                       scaled_score,
                       data=person_and_household, Hess = T)

# adding coefficients and p-values store table
ctable <- round(coef(summary(ordered_logit)),2)
# calculate and store p values
p <- round(pnorm(abs(ctable[,"t value"]), lower.tail = F)*2,3)
# odds ratio
oddsratio <- round(exp(coef(ordered_logit)),2)
# combined table
ctable <-cbind(ctable, "p value"=p, "odds ratio"=oddsratio)
ctable
```
\
<span style="color:#20b2aa">This model indicates that the interaction between race and the maximum household income could be significant.</span>
\
\

#### <span style="color:#009D6A">No significance</span> 

* Race*household lifecycle
* Race*housing tenure
* Race*residential type
* Race*education (min)
* Race*RGC
* Race*transit accessibility
* Race*total auto commute time